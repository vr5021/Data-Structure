# ê·¸ë˜í”„
  - ê°ì²´ì˜ ì¼ë¶€ ìŒë“¤ì´ 'ì—°ê´€ë˜ì–´' ìˆëŠ” ê°ì²´ ì§‘í•© êµ¬ì¡°ë¥¼ ë§í•œë‹¤.
  - ì •ì ê³¼ ê°„ì„ ìœ¼ë¡œ ì´ë£¨ì–´ì§„ë‹¤.
# P, NP
| ë¬¸ì œ ìœ í˜•   | ë‹¤í•­ ì‹œê°„ ë‚´ í’€ì´ ê°€ëŠ¥? | ë‹¤í•­ ì‹œê°„ ë‚´ ê²€ì¦ ê°€ëŠ¥? |
|------------|-----------------|-----------------|
| **P**      | âœ… ê°€ëŠ¥         | âœ… ê°€ëŠ¥         |
| **NP**     | â“ ëª¨ë¥´ì§€ë§Œ, ê°€ëŠ¥í•  ìˆ˜ë„ ìˆìŒ | âœ… ê°€ëŠ¥ |
| **NP-ì™„ì „** | â“ ëª¨ë¥´ì§€ë§Œ, ê°€ëŠ¥í•  ìˆ˜ë„ ìˆìŒ | âœ… ê°€ëŠ¥ |
| **NP-ë‚œí•´** | â“ ëª¨ë¥´ì§€ë§Œ, ê°€ëŠ¥í•  ìˆ˜ë„ ìˆìŒ | âŒ ë¶ˆê°€ëŠ¥í•  ìˆ˜ë„ ìˆìŒ |
# ê·¸ë˜í”„ ìˆœíšŒ
  - ê·¸ë˜í”„ íƒìƒ‰ì´ë¼ê³ ë„ ë¶ˆë¦¬ë©° ê·¸ë˜í”„ì˜ ê° ì •ì ì„ ë°©ë¬¸í•˜ëŠ” ê³¼ì •ì„ ë§í•œë‹¤.
  - ê¹Šì´ ìš°ì„  íƒìƒ‰(DFS, Depth-First Search), ë„ˆë¹„ ìš°ì„  íƒìƒ‰(BFS, Breadth-First Search)ì˜ 2ê°€ì§€ ì•Œê³ ë¦¬ì¦˜ì´ ìˆë‹¤.
  - ì¼ë°˜ì ìœ¼ë¡œ DFSê°€ ë„ë¦¬ ì“°ì¸ë‹¤.
  - ì¸ì ‘ í–‰ë ¬(Adjacency Matrix)ì™€ ì¸ì ‘ ë¦¬ìŠ¤íŠ¸(Adjacency List)ì˜ 2ê°€ì§€ ë°©ë²•ì´ ìˆë‹¤.
## DFS(ê¹Šì´ ìš°ì„  íƒìƒ‰)
  - ì¬ê·€ êµ¬ì¡°ë¡œ êµ¬í˜„
    ```pseudocode
    DFS(G, v)
      label v as discovered
      for all directed edges from v to w that are in G.adjacentEdges(v) do
          if vertex w is not labeled as discovered then
              recursively call DFS(G, w)
    ```
    ```python3
      def recursive_dfs(v, discovered=[]):
        discovered.append(v)
        for w in graph[v]:
          if w not in discovered:
            discovered = recursive_dfs(w, discovered)
        return discovered
    ```
    - ìŠ¤íƒì„ ì´ìš©í•œ ë°˜ë³µ êµ¬ì¡°ë¡œ êµ¬í˜„
      ```pseudocode
      DFS-iterative(G, v)
        let S be a stack
        S.push(v)
        while S is not empty do
            v = S.pop()
            if v is not labeled as discovered then
                label v as discovered
                for all edges from v to w in G.adjacentEdges(v) do
                    if w is not labeled as discovered then
                        S.push(w)
        ```
        ```python3
        def iteratice_dfs(start_v):
          discovered = []
          stack = [start_v]
          while stack:
            v = stack.pop()
            if v not in discovered:
              discovered.append(v)
              for w in graph[v]:
                stack.append(w)
          return discovered
        ```
## BFS(ë„ˆë¹„ ìš°ì„  íƒìƒ‰)
  - íë¥¼ ì´ìš©í•œ ë°˜ë³µ êµ¬ì¡°ë¡œ êµ¬í˜„
    ```pseudocode
    BFS(G, root)
      let Q be a queue
      label root as explored
      Q.enqueue(root)
      while Q is not empty do
          v := Q.dequeue()
          if v is the goal then
              return v
          for all edges from v to w in G.adjacentEdges(v) do
              if w is not labeled as explored then
                  label w as explored
                  w.parent := v
                  Q.enqueue(w)
    ```
    ```python3
    def iterative_bfs[start_v]:
      discovered = [start_v]
      queue = [start_v]
      while queue:
        v = queue.pop(0)
        for w in graph[v]:
          if w not in discovered:
            discovered.append(w)
            queue.append(w)
      return discovered
    ```
    - BFSëŠ” ì¬ê·€ë¡œ ë™ì‘í•˜ì§€ ì•ŠëŠ”ë‹¤.

# ë°±íŠ¸ë˜í‚¹
  -  í•´ê²°ì±…ì— ëŒ€í•œ í›„ë³´ë¥¼ êµ¬ì¶•í•´ ë‚˜ì•„ê°€ë‹¤ ê°€ëŠ¥ì„±ì´ ì—†ë‹¤ê³  íŒë‹¨ëœëŠ ì¦‰ì‹œ í›„ë³´ë¥¼ í¬ê¸°(Backtrack)í•´ ì •ë‹µì„ ì°¾ì•„ê°€ëŠ” ë²”ìš©ì ì¸ ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ì œì•½ ì¶©ì¡± ë¬¸ì œ(Constraint Satisfaction Problem)ì— íŠ¹íˆ ìœ ìš©í•˜ë‹¤.
  -  DFSê°€ ë°±íŠ¸ë˜í‚¹ì— ì†í•œë‹¤.
  -  ë¸Œë£¨íŠ¸ í¬ìŠ¤ì™€ ìœ ì‚¬í•˜ì§€ë§Œ ì¢€ ë” ìš°ì•„í•œ ë°©ì‹
  -  íŠ¸ë¦¬ì˜ ê°€ì§€ì¹˜ê¸°ì™€ ê°™ì•„ì„œ íŠ¸ë¦¬ì˜ íƒìƒ‰ ìµœì í™” ë¬¸ì œì™€ë„ ê´€ë ¨ì´ ê¹Šë‹¤.
# ì œì•½ ì¶©ì¡± ë¬¸ì œ(Constraint Satisfaction Problem)
  - ìˆ˜ë§ì€ ì œì•½ ì¡°ê±´ì„ ì¶©ì¡±í•˜ëŠ” ìƒíƒœë¥¼ ì°¾ì•„ë‚´ëŠ” ìˆ˜í•™ ë¬¸ì œ
  - ìŠ¤ë„ì¿ ì²˜ëŸ¼ 1ì—ì„œ 9ê¹Œì§€ ìˆ«ìë¥¼ í•œ ë²ˆë§Œ ë„£ëŠ”(ì œì•½ ì¡°ê±´ ì¶©ì¡±) ì •ë‹µ(ìƒíƒœ)ì„ ì°¾ì•„ë‚´ëŠ” ëª¨ë“  ë¬¸ì œ ìœ í˜•ì„ ë§í•¨
# [ì„¬ì˜ ê°œìˆ˜](https://leetcode.com/problems/number-of-islands/)
1ì„ ìœ¡ì§€ë¡œ, 0ì„ ë¬¼ë¡œ ê°€ì •í•œ 2D ê·¸ë¦¬ë“œ ë§µì´ ì£¼ì–´ì¡Œì„ ë•Œ, ì„¬ì˜ ê°œìˆ˜ë¥¼ ê³„ì‚°í•˜ë¼.(ì—°ê²°ë˜ì–´ ìˆëŠ” 1ì˜ ë©ì–´ë¦¬ ê°œìˆ˜ë¥¼ êµ¬í•˜ë¼.)
  - í’€ì´ 1 DFSë¡œ ê·¸ë˜í”„ íƒìƒ‰
    - ë™ì„œë‚¨ë¶ì´ ëª¨ë‘ ì—°ê²°ëœ ê·¸ë˜í”„ë¡œ ê°€ì •í•˜ê³  ë„¤ ë°©í–¥ ê°ê° DFS ì¬ê·€ë¥¼ ì´ìš©í•œ ë™ì¼í•œ í˜•íƒœë¡œ íƒìƒ‰
    - íƒìƒ‰ì„ ëë§ˆì¹˜ë©´ 1ì´ ì¦ê°€í•˜ëŠ” í˜•íƒœ
    ```python3
    def numIslands(self, grid: List[List[str]]) -> int:
      def dfs(i, j):
        # ë” ì´ìƒ ë•…ì´ ì•„ë‹Œ ê²½ìš° ì¢…ë£Œ
        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != '1':
          return
    
        grid[i][j] = 0
    
        # ë™ì„œë‚¨ë¶ íƒìƒ‰
        dfs(i + 1, j)
        dfs(i - 1, j)
        dfs(i, j + 1)
        dfs(i, j - 1)
    
      count = 0
      for i in range(len(grid)):
        for j in range(len(grid[0])):
          if grid[i][j] == '1':
            dfs(i, j)
            # ëª¨ë“  ìœ¡ì§€ íƒìƒ‰ í›„ ì¹´ìš´íŠ¸ 1 ì¦ê°€
            count += 1
      return count
    ```

# [ì „í™” ë²ˆí˜¸ ë¬¸ì ì¡°í•©](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)
2ì—ì„œ 9ê¹Œì§€ ìˆ«ìê°€ ì£¼ì–´ì¡Œì„ ë•Œ ì „í™” ë²ˆí˜¸ë¡œ ì¡°í•© ê°€ëŠ¥í•œ ëª¨ë“  ë¬¸ìë¥¼ ì¶œë ¥í•˜ë¼.
  - í’€ì´ 1 ëª¨ë“  ì¡°í•© íƒìƒ‰
  ```python3
  def letterCombinations(self, digits: str) -> List[str]:
    def dfs(index, path):
      # ëê¹Œì§€ íƒìƒ‰í•˜ë©´ ë°±íŠ¸ë˜í‚¹
      if len(path) == len(digits):
        result.append(path)
        return
  
      # ì…ë ¥ê°’ ìë¦¿ìˆ˜ ë‹¨ìœ„ ë°˜ë³µ
      for i in range(index, len(digits)):
        # ìˆ«ìì— í•´ë‹¹í•˜ëŠ” ëª¨ë“  ë¬¸ìì—´ ë°˜ë³µ
        for j in dic[digits[i]]:
          dfs(i + 1, path + j)
    # ì˜ˆì™¸ ì²˜ë¦¬
    if not digits:
      return []  
  
    dic = {"2": "abc", "3": "def", "4": "ghi", "5": "jkl", "6": "mno", "7": "pqrs", "8": "tuv", "9": "wxyz"}
    result = []
    dfs(0, "")
    
    return result
  ```

# [ìˆœì—´](https://leetcode.com/problems/permulations/)
ì„œë¡œ ë‹¤ë¥¸ ì •ìˆ˜ë¥¼ ì…ë ¥ë°›ì•„ ê°€ëŠ¥í•œ ëª¨ë“  ìˆœì—´ì„ ë¦¬í„´í•˜ë¼.
  - í’€ì´ 1 DFSë¥¼ í™œìš©í•œ ìˆœì—´ ìƒì„±
    - ìê¸° ìì‹ ì„ ì œì™¸í•œ ëª¨ë“  ìš”ì†Œë¥¼ next_elementsë¡œ ì²˜ë¦¬
    - elements: ì•„ì§ ì„ íƒë˜ì§€ ì•Šì€ ìˆ«ìë“¤
    - prev_elements: ì§€ê¸ˆê¹Œì§€ ì„ íƒí•œ ìˆ«ìë“¤
    - next_elements: ë‹¤ìŒ DFS í˜¸ì¶œì„ ìœ„í•œ ìˆ«ìë“¤
    - ë‹¤ìŒ ìˆ«ì ì„ íƒì„ ìœ„í•´ í˜„ì¬ ìˆ«ì remove, append.
    - ì™„ì „í•œ ìˆœì—´ì‹œ í•œ ë‹¨ê³„ ìœ„ì˜ ë…¸ë“œë¡œ ëŒì•„ê°€ì•¼ í•˜ë¯€ë¡œ ë¦¬í”„ë…¸ë“œì˜ ìˆ«ì ì œê±° pop.
    - ì´í›„ ë‚˜ë¨¸ì§€ ë¦¬í”„ ë…¸ë“œ ì„ íƒ for e in elements
    ```python3
    def permute(self, nums: List[int]) -> List[List[int]]:
      result = []
      prev_elements = []
    
      def dfs(elements):
        # ë¦¬í”„ ë…¸ë“œì¼ ë•Œ ê²°ê³¼ ì¶”ê°€
        if len(elements) == 0:
          result.append(prev_elements[:]) 
    
        # ìˆœì—´ ìƒì„± ì¬ê·€ í˜¸ì¶œ
        for e in elements:
          next_elements = elements[:] # ì°¸ì¡°ê°€ ì•„ë‹Œ ê°’ ë³µì‚¬
          next_elements.remove(e)
          
          prev_elements.append(e)
          dfs(next_elements)
          prev_elements.pop()
      dfs(nums)
      return result
      ```
  - í’€ì´ 2 itertools ëª¨ë“ˆ ì‚¬ìš©
    ```python3
    def permute(self, nums: List[int]) -> List[List[int]]:
      return list(itertools.permulations(nums))
    ```
# [ì¡°í•©](https://leetcode.com/problems/combinations/)
ì „ì²´ ìˆ˜ nì„ ì…ë ¥ë°›ì•„ kê°œì˜ ì¡°í•©ì„ ë¦¬í„´í•˜ë¼.
  - í’€ì´ 1 DFSë¡œ kê°œ ì¡°í•© ìƒì„±
    - ìê¸° ìì‹  ë¿ ì•„ë‹ˆë¼ ì•ì˜ ëª¨ë“  ìš”ì†Œë¥¼ ë°°ì œí•˜ê³  next_elements êµ¬ì„±
    - ë…¸ë“œê°€ ë‚´ë ¤ê°ˆìˆ˜ë¡ këŠ” 1ì”© ê°ì†Œí•˜ê³  ì´ì „ì˜ ëª¨ë“  ìš”ì†ŒëŠ” ë°°ì œí•´ì•¼í•˜ë¯€ë¡œ ì‹œì‘ ìœ„ì¹˜ëŠ” 1ì”© ì¦ê°€
    - ëŒì•„ê°€ì•¼í•˜ë¯€ë¡œ pop
  ```python3
  def combine(n: int, k: int) -> List[List[int]]:
    results = []

    def dfs(elements, start: int, k: int):
      if k == 0:
        results.append(elements[:])
        return
  
      # ìì‹  ì´ì „ì˜ ëª¨ë“  ê°’ì„ ê³ ì •í•˜ì—¬ ì¬ê·€ í˜¸ì¶œ
      for i in range(start, n + 1):
        elements.append(i)
        dfs(elements, i + 1, k - 1)
        elements.pop()

  dfs([], 1, k)
  return results
  ```
  - í’€ì´ 2 itertools ëª¨ë“ˆ ì‚¬ìš©
    ```python3
    def combine(n: int, k: int) -> List[List[int]]:
      return list(itertools.combinations(range(1, n + 1), k)
# [ì¡°í•©ì˜ í•©](https://leetcode.com/problems/combination-sum/)
ìˆ«ì ì§‘í•© candidatesë¥¼ ì¡°í•©í•˜ì—¬ í•©ì´ targetì´ ë˜ëŠ” ì›ì†Œë¥¼ ë‚˜ì—´í•˜ë¼. ê° ì›ì†ŒëŠ” ì¤‘ë³µìœ¼ë¡œ ë‚˜ì—´ ê°€ëŠ¥í•˜ë‹¤.
  - í’€ì´ 1 DFSë¡œ ì¤‘ë³µ ì¡°í•© ê·¸ë˜í”„ íƒìƒ‰
    - ì¡°í•©ì´ë¯€ë¡œ ìì‹ ë¶€í„° ì‹œì‘í•˜ëŠ” í•˜ìœ„ ë…¸ë“œ íƒìƒ‰
    ```python3
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]
      result = []
    
      def dfs(csum, index, path):
        # ì¢…ë£Œ ì¡°ê±´
        if csum < 0:
            return
        if csum == 0:
            result.append(path)
            return
    
        # ìì‹  ë¶€í„° í•˜ìœ„ ì›ì†Œê¹Œì§€ì˜ ë‚˜ì—´ ì¬ê·€ í˜¸ì¶œ
        for i in range(index, len(candidates)):
          dfs(csum - candidates[i], i, path + [candidates[i]])
    
      dfs(target, 0, [])
      return result
    ```
# [ë¶€ë¶„ ì§‘í•©](https://leetcode.com/problems/subsets/)
ëª¨ë“  ë¶€ë¶„ ì§‘í•©ì„ ë¦¬í„´í•˜ë¼.
  - í’€ì´ 1 íŠ¸ë¦¬ì˜ ëª¨ë“  DFSê²°ê³¼
    - íŠ¸ë¦¬ë¥¼ êµ¬ì„±í•˜ê³  íŠ¸ë¦¬ë¥¼ DFSí•˜ëŠ” ë¬¸ì œë¡œ í’€ì´í•  ìˆ˜ ìˆë‹¤.
    - ê²½ë¡œë¥¼ ë§Œë“¤ì–´ ë‚˜ê°€ë©´ì„œ ì¸ë±ìŠ¤ë¥¼ 1ì”© ì¦ê°€í•˜ëŠ” í˜•íƒœë¡œ ê¹Šì´ íƒìƒ‰
    - ëª¨ë“  íƒìƒ‰ì˜ ê²½ë¡œê°€ ì •ë‹µì´ë¯€ë¡œ íƒìƒ‰í•  ë•Œë§ˆë‹¤ ê²°ê³¼ ì¶”ê°€
    ```python3
    def subsets(self, nums: List[int]) -> List[List[int]]:
      result = []
    
      def dfs(index, path):
        # ë§¤ë²ˆ ê²°ê³¼ ì¶”ê°€
        result.append(path)
        
        # ê²½ë¡œë¥¼ ë§Œë“¤ë©´ì„œ DFS
        for i in range(index, len(nums)):
          dfs(i + 1, path + [nums[i]])
  
      dfs(0, [])
      return result
    ```
# [ì¼ì • ì¬êµ¬ì„±](https://leetcode.com/problems/reconstruct-itinerary/)
[from, to]ë¡œ êµ¬ì„±ëœ í•­ê³µê¶Œ ëª©ë¡ì„ ì´ìš©í•´ JFKì—ì„œ ì¶œë°œí•˜ëŠ” ì—¬í–‰ ì¼ì •ì„ êµ¬ì„±í•˜ë¼.        
ì—¬ëŸ¬ ì¼ì •ì´ ìˆëŠ” ê²½ìš° ì‚¬ì „ ì–´íœ˜ ìˆœìœ¼ë¡œ ë°©ë¬¸í•œë‹¤.
  - í’€ì´ 1 DFSë¡œ ì¼ì • ê·¸ë˜í”„ êµ¬ì„±
    ```python3
    def findItinerary(self, tickets: List[List[str]]) -> List[str]:
      graph = collections.defaultdict(list)
      # ê·¸ë˜í”„ ì–´íœ˜ ìˆœì„œëŒ€ë¡œ êµ¬ì„±
      for src, dst in sorted(tickets):
        graph[src].append(dst)
    
      route = []
      def dfs(src):
        # ì–´íœ˜ ìˆœ êµ¬ì„±ì´ë¯€ë¡œ ì²« ë²ˆì§¸ ê°’ì„ ì½ì–´ ì–´íœ˜ ìˆœ ë°©ë¬¸
        while graph[src]:
          dfs(graph[src].pop(0))
        route.append(src) # ì—­ìˆœìœ¼ë¡œ ë‹´ê¸°ê²Œ ë¨
    
      dfs('JFK')
      # ë‹¤ì‹œ ë’¤ì§‘ì–´ ì–´íœ˜ ìˆ˜ ê²°ê³¼ë¡œ
      return route[::-1]
    ```
- í’€ì´ 2 ìŠ¤íƒ ì—°ì‚°ìœ¼ë¡œ í ì—°ì‚° ìµœì í™” ì‹œë„
  ```python3
    def findItinerary(self, tickets: List[List[str]]) -> List[str]:
      graph = collections.defaultdict(list)
      # ê·¸ë˜í”„ë¥¼ ë’¤ì§‘ì–´ì„œ êµ¬ì„±
      for src, dst in sorted(tickets, reverse=True):
        graph[src].append(dst)
    
      route = []
      def dfs(src):
        # ë§ˆì§€ë§‰ ê°’ì„ ì½ì–´ ì–´íœ˜ ìˆœ ë°©ë¬¸
        while graph[src]:
          dfs(graph[src].pop())
        route.append(src)
    
      dfs('JFK')
      # ë‹¤ì‹œ ë’¤ì§‘ì–´ ì–´íœ˜ ìˆœ ê²°ê³¼ë¡œ
      return route[::-1]
  ```
  - í’€ì´ 3 ì¼ì • ê·¸ë˜í”„ ë°˜ë³µ
    - stackì„ ì´ìš©í•œ ë°˜ë³µìœ¼ë¡œ ì¶”ì¶œ
    ```python3
    def findItinerary(self, tickets: List[List[str]]) -> List[str]:
      graph = collections.defaultdict(list)
      # ê·¸ë˜í”„ ìˆœì„œëŒ€ë¡œ êµ¬ì„±
      for src, dst in sorted(tickets):
        graph[src].append(dst)
    
      route, stack = [], ['JFK']
      while stack:
        # ë°˜ë³µìœ¼ë¡œ ìŠ¤íƒì„ êµ¬ì„±í•˜ë˜ ë§‰íˆëŠ” ë¶€ë¶„ì—ì„œ ì¶”ì¶œ
        while graph[stack[-1]]:
          stack.append(graph[stack[-1]].pop(0))
        route.append(stack.pop())
        
      # ë‹¤ì‹œ ë’¤ì§‘ì–´ ì–´íœ˜ ìˆœ ê²°ê³¼ë¡œ
      return route[::-1]
    ```
    ğŸ“Œ 2ï¸âƒ£ DFS ì§„í–‰ (`while stack`)
    | í˜„ì¬ `stack` | ì‹¤í–‰ | ì—…ë°ì´íŠ¸ í›„ `stack` | `route` |
    |--------------|------------------------|------------------|----------|
    | `['JFK']` | `stack.append('ATL')` | `['JFK', 'ATL']` | `[]` |
    | `['JFK', 'ATL']` | `stack.append('JFK')` | `['JFK', 'ATL', 'JFK']` | `[]` |
    | `['JFK', 'ATL', 'JFK']` | `stack.append('LAX')` | `['JFK', 'ATL', 'JFK', 'LAX']` | `[]` |
    | `['JFK', 'ATL', 'JFK', 'LAX']` | `stack.append('ATL')` | `['JFK', 'ATL', 'JFK', 'LAX', 'ATL']` | `[]` |
    
    ---
    
    ğŸ“Œ 3ï¸âƒ£ ë§‰íˆëŠ” ê³³ì—ì„œ `route.append(stack.pop())` ì‹¤í–‰
    | í˜„ì¬ `stack` | ì‹¤í–‰ | ì—…ë°ì´íŠ¸ í›„ `stack` | `route` |
    |--------------|-------------------------|------------------|------------------------|
    | `['JFK', 'ATL', 'JFK', 'LAX', 'ATL']` | `route.append('ATL')` | `['JFK', 'ATL', 'JFK', 'LAX']` | `['ATL']` |
    | `['JFK', 'ATL', 'JFK', 'LAX']` | `route.append('LAX')` | `['JFK', 'ATL', 'JFK']` | `['ATL', 'LAX']` |
    | `['JFK', 'ATL', 'JFK']` | `route.append('JFK')` | `['JFK', 'ATL']` | `['ATL', 'LAX', 'JFK']` |
    | `['JFK', 'ATL']` | `route.append('ATL')` | `['JFK']` | `['ATL', 'LAX', 'JFK', 'ATL']` |
    | `['JFK']` | `route.append('JFK')` | `[]` | `['ATL', 'LAX', 'JFK', 'ATL', 'JFK']` |

# [ì½”ìŠ¤ ìŠ¤ì¼€ì¤„](https://leetcode.com/problems/course-schedule/)
0ì„ ì™„ë£Œí•˜ê¸° ìœ„í•´ì„œëŠ” 1ì„ ëë‚´ì•¼ í•œë‹¤ëŠ” ê²ƒì„ [0,1] ìŒìœ¼ë¡œ í‘œí˜„í•˜ëŠ” nê°œì˜ ì½”ìŠ¤ê°€ ìˆë‹¤.         
ì½”ìŠ¤ ê°œìˆ˜ nê³¼ ì´ ìŒë“¤ì„ ì…ë ¥ìœ¼ë¡œ ë°›ì•˜ì„ ë•Œ ëª¨ë“  ì½”ìŠ¤ê°€ ì™„ë£Œ ê°€ëŠ¥í•œì§€ íŒë³„í•˜ë¼.
  - í’€ì´ 1 DFSë¡œ ìˆœí™˜ êµ¬ì¡° íŒë³„
    - ê·¸ë˜í”„ê°€ ìˆœí™˜ êµ¬ì¡°ì¸ì§€ë¥¼ íŒë³„í•˜ëŠ” ë¬¸ì œë¡œ í’€ì´í•  ìˆ˜ ìˆë‹¤.
    - ìˆœí™˜ êµ¬ì¡°ì¼ ê²½ìš° í•´ë‹¹ ì½”ìŠ¤ëŠ” ì²˜ë¦¬í•  ìˆ˜ ì—†ìŒ
    - ì´ë¯¸ ë°©ë¬¸í–ˆë˜ ë…¸ë“œë¥¼ set traced ë³€ìˆ˜ì— ì €ì¥í•˜ì—¬ ì´ë¯¸ ë°©ë¬¸í•œ ê³³ì„ ì¤‘ë³µ ë°©ë¬¸í•˜ê²Œ ë˜ë©´ ìˆœí™˜ êµ¬ì¡°
    - í•´ë‹¹ ë…¸ë“œë¥¼ ì´ìš©í•œ ëª¨ë“  íƒìƒ‰ì´ ëë‚˜ë©´ traced.remove(i)ë¡œ ë°©ë¬¸í•œ ë‚´ì—­ì„ ë°˜ë“œì‹œ ì‚­ì œí•´ì•¼ í•œë‹¤. ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ ë‹¤ë¥¸ ë…¸ë“œê°€ ë°©ë¬¸í•œ ë…¸ë“œê¹Œì§€ ë‚¨ê²Œ ë˜ì–´ ì¤‘ë³µ ë°©ë¬¸ì´ë¼ ì°©ê°í•˜ê¸° ë•Œë¬¸.
    - 
    '''python3
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool
      graph = collections.defaultdict(list)
      # ê·¸ë˜í”„ êµ¬ì„±
      for course, pre in prerequisites:
        graph[course].append(pre)
    
      traced = set()
      # DFS
      def dfs(course):
        # ìˆœí™˜ êµ¬ì¡°ì´ë©´ False
        if course in traced:
          return False
    
        traced.add(course)
        for pre in graph[course]:
          if not dfs(pre): # ìˆœí™˜ êµ¬ì¡°ë¡œ í•˜ìœ„ë…¸ë“œì—ì„œ Falseê°€ ë‚˜ì˜¤ë©´ ì´ì–´ì„œ False return
            return False
        # íƒìƒ‰ ì¢…ë¥˜ í›„ ìˆœí™˜ ë…¸ë“œ ì‚­ì œ
        traced.remove(course)
    
        return True
    
      # ëª¨ë“  ê°„ì„ ì„ íƒìƒ‰í•˜ë©° ìˆœí™˜ì´ ì—†ëŠ”ì§€ í™•ì¸
      for course in list(graph): # graphëŠ” defaultdictë¡œ ì¤‘ê°„ì— ê°’ì´ ë³€ê²½ë˜ì–´ ì˜¤ë¥˜ê°€ ë°œìƒí•˜ë¯€ë¡œ listë¡œ ê°ì‹¸ ê°’ì„ ë³µì‚¬í•˜ì—¬ íƒìƒ‰ ì‹¤í–‰
        if not dfs(course): 
          return False
    
      return True
    ```
  - í’€ì´ 2 ê°€ì§€ì¹˜ê¸°ë¥¼ ì´ìš©í•œ ìµœì í™”
    - ì´ë¯¸ ë°©ë¬¸í–ˆë˜ ë…¸ë“œë¼ë©´ ë” ì´ìƒ ì§„í–‰í•˜ì§€ ì•Šê³  True ë¦¬í„´
    ```python3
    def canFinish(Self, numCourses: int, prerequisites: List[List[int]]) -> bool:
      graph = collections.defaultdict(list)
      # ê·¸ë˜í”„ êµ¬ì„±
      for course, pre in prerequisites:
        graph[course].append(pre)
    
      traced = set()
      visited = set()
    
      # DFS
      def dfs(course):
        # ìˆœí™˜ êµ¬ì¡°ì´ë©´ False
        if course in traced:
          return False
    
        # ì´ë¯¸ ë°©ë¬¸í–ˆë˜ ë…¸ë“œì´ë©´ True
        if course in visited:
          return True
    
        traced.add(course)
        for pre in graph[course]:
          if not dfs(pre):
            return False
    
        # íƒìƒ‰ ì¢…ë¥˜ í›„ ìˆœí™˜ ë…¸ë“œ ì‚­ì œ
        traced.remove(course)
        # íƒìƒ‰ ì¢…ë£Œ í›„ ìˆœí™˜ ë…¸ë“œ ì‚­ì œ
        visited.add(course)
    
        return True
      # ëª¨ë“  ê°„ì„ ì„ íƒìƒ‰í•˜ë©° ìˆœí™˜ì´ ì—†ëŠ”ì§€ í™•ì¸
      for course in list(graph):
        if not dfs(course):
          return False
          
      return True
    ```
    


    
