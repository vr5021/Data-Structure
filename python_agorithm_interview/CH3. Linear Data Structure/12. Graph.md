# 그래프
  - 객체의 일부 쌍들이 '연관되어' 있는 객체 집합 구조를 말한다.
  - 정점과 간선으로 이루어진다.
# P, NP
| 문제 유형   | 다항 시간 내 풀이 가능? | 다항 시간 내 검증 가능? |
|------------|-----------------|-----------------|
| **P**      | ✅ 가능         | ✅ 가능         |
| **NP**     | ❓ 모르지만, 가능할 수도 있음 | ✅ 가능 |
| **NP-완전** | ❓ 모르지만, 가능할 수도 있음 | ✅ 가능 |
| **NP-난해** | ❓ 모르지만, 가능할 수도 있음 | ❌ 불가능할 수도 있음 |
# 그래프 순회
  - 그래프 탐색이라고도 불리며 그래프의 각 정점을 방문하는 과정을 말한다.
  - 깊이 우선 탐색(DFS, Depth-First Search), 너비 우선 탐색(BFS, Breadth-First Search)의 2가지 알고리즘이 있다.
  - 일반적으로 DFS가 널리 쓰인다.
  - 인접 행렬(Adjacency Matrix)와 인접 리스트(Adjacency List)의 2가지 방법이 있다.
## DFS(깊이 우선 탐색)
  - 재귀 구조로 구현
    ```pseudocode
    DFS(G, v)
      label v as discovered
      for all directed edges from v to w that are in G.adjacentEdges(v) do
          if vertex w is not labeled as discovered then
              recursively call DFS(G, w)
    ```
    ```python3
      def recursive_dfs(v, discovered=[]):
        discovered.append(v)
        for w in graph[v]:
          if w not in discovered:
            discovered = recursive_dfs(w, discovered)
        return discovered
    ```
    - 스택을 이용한 반복 구조로 구현
      ```pseudocode
      DFS-iterative(G, v)
        let S be a stack
        S.push(v)
        while S is not empty do
            v = S.pop()
            if v is not labeled as discovered then
                label v as discovered
                for all edges from v to w in G.adjacentEdges(v) do
                    if w is not labeled as discovered then
                        S.push(w)
        ```
        ```python3
        def iteratice_dfs(start_v):
          discovered = []
          stack = [start_v]
          while stack:
            v = stack.pop()
            if v not in discovered:
              discovered.append(v)
              for w in graph[v]:
                stack.append(w)
          return discovered
        ```
## BFS(너비 우선 탐색)
  - 큐를 이용한 반복 구조로 구현
    ```pseudocode
    BFS(G, root)
      let Q be a queue
      label root as explored
      Q.enqueue(root)
      while Q is not empty do
          v := Q.dequeue()
          if v is the goal then
              return v
          for all edges from v to w in G.adjacentEdges(v) do
              if w is not labeled as explored then
                  label w as explored
                  w.parent := v
                  Q.enqueue(w)
    ```
    ```python3
    def iterative_bfs[start_v]:
      discovered = [start_v]
      queue = [start_v]
      while queue:
        v = queue.pop(0)
        for w in graph[v]:
          if w not in discovered:
            discovered.append(w)
            queue.append(w)
      return discovered
    ```
    - BFS는 재귀로 동작하지 않는다.

# 백트래킹
  -  해결책에 대한 후보를 구축해 나아가다 가능성이 없다고 판단된느 즉시 후보를 포기(Backtrack)해 정답을 찾아가는 범용적인 알고리즘으로 제약 충족 문제(Constraint Satisfaction Problem)에 특히 유용하다.
  -  DFS가 백트래킹에 속한다.
  -  브루트 포스와 유사하지만 좀 더 우아한 방식
  -  트리의 가지치기와 같아서 트리의 탐색 최적화 문제와도 관련이 깊다.
# 제약 충족 문제(Constraint Satisfaction Problem)
  - 수많은 제약 조건을 충족하는 상태를 찾아내는 수학 문제
  - 스도쿠처럼 1에서 9까지 숫자를 한 번만 넣는(제약 조건 충족) 정답(상태)을 찾아내는 모든 문제 유형을 말함
# [섬의 개수](https://leetcode.com/problems/number-of-islands/)
1을 육지로, 0을 물로 가정한 2D 그리드 맵이 주어졌을 때, 섬의 개수를 계산하라.(연결되어 있는 1의 덩어리 개수를 구하라.)
  - 풀이 1 DFS로 그래프 탐색
    - 동서남북이 모두 연결된 그래프로 가정하고 네 방향 각각 DFS 재귀를 이용한 동일한 형태로 탐색
    - 탐색을 끝마치면 1이 증가하는 형태
    ```python3
    def numIslands(self, grid: List[List[str]]) -> int:
      def dfs(i, j):
        # 더 이상 땅이 아닌 경우 종료
        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != '1':
          return
    
        grid[i][j] = 0
    
        # 동서남북 탐색
        dfs(i + 1, j)
        dfs(i - 1, j)
        dfs(i, j + 1)
        dfs(i, j - 1)
    
      count = 0
      for i in range(len(grid)):
        for j in range(len(grid[0])):
          if grid[i][j] == '1':
            dfs(i, j)
            # 모든 육지 탐색 후 카운트 1 증가
            count += 1
      return count
    ```

# [전화 번호 문자 조합](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)
2에서 9까지 숫자가 주어졌을 때 전화 번호로 조합 가능한 모든 문자를 출력하라.
  - 풀이 1 모든 조합 탐색
  ```python3
  def letterCombinations(self, digits: str) -> List[str]:
    def dfs(index, path):
      # 끝까지 탐색하면 백트래킹
      if len(path) == len(digits):
        result.append(path)
        return
  
      # 입력값 자릿수 단위 반복
      for i in range(index, len(digits)):
        # 숫자에 해당하는 모든 문자열 반복
        for j in dic[digits[i]]:
          dfs(i + 1, path + j)
    # 예외 처리
    if not digits:
      return []  
  
    dic = {"2": "abc", "3": "def", "4": "ghi", "5": "jkl", "6": "mno", "7": "pqrs", "8": "tuv", "9": "wxyz"}
    result = []
    dfs(0, "")
    
    return result
  ```

# [순열](https://leetcode.com/problems/permulations/)
서로 다른 정수를 입력받아 가능한 모든 순열을 리턴하라.
  - 풀이 1 DFS를 활용한 순열 생성
    - 자기 자신을 제외한 모든 요소를 next_elements로 처리
    - elements: 아직 선택되지 않은 숫자들
    - prev_elements: 지금까지 선택한 숫자들
    - next_elements: 다음 DFS 호출을 위한 숫자들
    - 다음 숫자 선택을 위해 현재 숫자 remove, append.
    - 완전한 순열시 한 단계 위의 노드로 돌아가야 하므로 리프노드의 숫자 제거 pop.
    - 이후 나머지 리프 노드 선택 for e in elements
    ```python3
    def permute(self, nums: List[int]) -> List[List[int]]:
      result = []
      prev_elements = []
    
      def dfs(elements):
        # 리프 노드일 때 결과 추가
        if len(elements) == 0:
          result.append(prev_elements[:]) 
    
        # 순열 생성 재귀 호출
        for e in elements:
          next_elements = elements[:] # 참조가 아닌 값 복사
          next_elements.remove(e)
          
          prev_elements.append(e)
          dfs(next_elements)
          prev_elements.pop()
      dfs(nums)
      return result
      ```
  - 풀이 2 itertools 모듈 사용
    ```python3
    def permute(self, nums: List[int]) -> List[List[int]]:
      return list(itertools.permulations(nums))
    ```
# [조합](https://leetcode.com/problems/combinations/)
전체 수 n을 입력받아 k개의 조합을 리턴하라.
  - 풀이 1 DFS로 k개 조합 생성
    - 자기 자신 뿐 아니라 앞의 모든 요소를 배제하고 next_elements 구성
    - 노드가 내려갈수록 k는 1씩 감소하고 이전의 모든 요소는 배제해야하므로 시작 위치는 1씩 증가
    - 돌아가야하므로 pop
  ```python3
  def combine(n: int, k: int) -> List[List[int]]:
    results = []

    def dfs(elements, start: int, k: int):
      if k == 0:
        results.append(elements[:])
        return
  
      # 자신 이전의 모든 값을 고정하여 재귀 호출
      for i in range(start, n + 1):
        elements.append(i)
        dfs(elements, i + 1, k - 1)
        elements.pop()

  dfs([], 1, k)
  return results
  ```
  - 풀이 2 itertools 모듈 사용
    ```python3
    def combine(n: int, k: int) -> List[List[int]]:
      return list(itertools.combinations(range(1, n + 1), k)
# [조합의 합](https://leetcode.com/problems/combination-sum/)
숫자 집합 candidates를 조합하여 합이 target이 되는 원소를 나열하라. 각 원소는 중복으로 나열 가능하다.
  - 풀이 1 DFS로 중복 조합 그래프 탐색
    - 조합이므로 자신부터 시작하는 하위 노드 탐색
    ```python3
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]
      result = []
    
      def dfs(csum, index, path):
        # 종료 조건
        if csum < 0:
            return
        if csum == 0:
            result.append(path)
            return
    
        # 자신 부터 하위 원소까지의 나열 재귀 호출
        for i in range(index, len(candidates)):
          dfs(csum - candidates[i], i, path + [candidates[i]])
    
      dfs(target, 0, [])
      return result
    ```
# [부분 집합](https://leetcode.com/problems/subsets/)
모든 부분 집합을 리턴하라.
  - 풀이 1 트리의 모든 DFS결과
    - 트리를 구성하고 트리를 DFS하는 문제로 풀이할 수 있다.
    - 경로를 만들어 나가면서 인덱스를 1씩 증가하는 형태로 깊이 탐색
    - 모든 탐색의 경로가 정답이므로 탐색할 때마다 결과 추가
    ```python3
    def subsets(self, nums: List[int]) -> List[List[int]]:
      result = []
    
      def dfs(index, path):
        # 매번 결과 추가
        result.append(path)
        
        # 경로를 만들면서 DFS
        for i in range(index, len(nums)):
          dfs(i + 1, path + [nums[i]])
  
      dfs(0, [])
      return result
    ```
# [일정 재구성](https://leetcode.com/problems/reconstruct-itinerary/)
[from, to]로 구성된 항공권 목록을 이용해 JFK에서 출발하는 여행 일정을 구성하라.        
여러 일정이 있는 경우 사전 어휘 순으로 방문한다.
  - 풀이 1 DFS로 일정 그래프 구성
    ```python3
    def findItinerary(self, tickets: List[List[str]]) -> List[str]:
      graph = collections.defaultdict(list)
      # 그래프 어휘 순서대로 구성
      for src, dst in sorted(tickets):
        graph[src].append(dst)
    
      route = []
      def dfs(src):
        # 어휘 순 구성이므로 첫 번째 값을 읽어 어휘 순 방문
        while graph[src]:
          dfs(graph[src].pop(0))
        route.append(src) # 역순으로 담기게 됨
    
      dfs('JFK')
      # 다시 뒤집어 어휘 수 결과로
      return route[::-1]
    ```
- 풀이 2 스택 연산으로 큐 연산 최적화 시도
  ```python3
    def findItinerary(self, tickets: List[List[str]]) -> List[str]:
      graph = collections.defaultdict(list)
      # 그래프를 뒤집어서 구성
      for src, dst in sorted(tickets, reverse=True):
        graph[src].append(dst)
    
      route = []
      def dfs(src):
        # 마지막 값을 읽어 어휘 순 방문
        while graph[src]:
          dfs(graph[src].pop())
        route.append(src)
    
      dfs('JFK')
      # 다시 뒤집어 어휘 순 결과로
      return route[::-1]
  ```
  - 풀이 3 일정 그래프 반복
    - stack을 이용한 반복으로 추출
    ```python3
    def findItinerary(self, tickets: List[List[str]]) -> List[str]:
      graph = collections.defaultdict(list)
      # 그래프 순서대로 구성
      for src, dst in sorted(tickets):
        graph[src].append(dst)
    
      route, stack = [], ['JFK']
      while stack:
        # 반복으로 스택을 구성하되 막히는 부분에서 추출
        while graph[stack[-1]]:
          stack.append(graph[stack[-1]].pop(0))
        route.append(stack.pop())
        
      # 다시 뒤집어 어휘 순 결과로
      return route[::-1]
    ```
    📌 2️⃣ DFS 진행 (`while stack`)
    | 현재 `stack` | 실행 | 업데이트 후 `stack` | `route` |
    |--------------|------------------------|------------------|----------|
    | `['JFK']` | `stack.append('ATL')` | `['JFK', 'ATL']` | `[]` |
    | `['JFK', 'ATL']` | `stack.append('JFK')` | `['JFK', 'ATL', 'JFK']` | `[]` |
    | `['JFK', 'ATL', 'JFK']` | `stack.append('LAX')` | `['JFK', 'ATL', 'JFK', 'LAX']` | `[]` |
    | `['JFK', 'ATL', 'JFK', 'LAX']` | `stack.append('ATL')` | `['JFK', 'ATL', 'JFK', 'LAX', 'ATL']` | `[]` |
    
    ---
    
    📌 3️⃣ 막히는 곳에서 `route.append(stack.pop())` 실행
    | 현재 `stack` | 실행 | 업데이트 후 `stack` | `route` |
    |--------------|-------------------------|------------------|------------------------|
    | `['JFK', 'ATL', 'JFK', 'LAX', 'ATL']` | `route.append('ATL')` | `['JFK', 'ATL', 'JFK', 'LAX']` | `['ATL']` |
    | `['JFK', 'ATL', 'JFK', 'LAX']` | `route.append('LAX')` | `['JFK', 'ATL', 'JFK']` | `['ATL', 'LAX']` |
    | `['JFK', 'ATL', 'JFK']` | `route.append('JFK')` | `['JFK', 'ATL']` | `['ATL', 'LAX', 'JFK']` |
    | `['JFK', 'ATL']` | `route.append('ATL')` | `['JFK']` | `['ATL', 'LAX', 'JFK', 'ATL']` |
    | `['JFK']` | `route.append('JFK')` | `[]` | `['ATL', 'LAX', 'JFK', 'ATL', 'JFK']` |

# [코스 스케줄](https://leetcode.com/problems/course-schedule/)
0을 완료하기 위해서는 1을 끝내야 한다는 것을 [0,1] 쌍으로 표현하는 n개의 코스가 있다.         
코스 개수 n과 이 쌍들을 입력으로 받았을 때 모든 코스가 완료 가능한지 판별하라.
  - 풀이 1 DFS로 순환 구조 판별
    - 그래프가 순환 구조인지를 판별하는 문제로 풀이할 수 있다.
    - 순환 구조일 경우 해당 코스는 처리할 수 없음
    - 이미 방문했던 노드를 set traced 변수에 저장하여 이미 방문한 곳을 중복 방문하게 되면 순환 구조
    - 해당 노드를 이용한 모든 탐색이 끝나면 traced.remove(i)로 방문한 내역을 반드시 삭제해야 한다. 그렇지 않으면 다른 노드가 방문한 노드까지 남게 되어 중복 방문이라 착각하기 때문.
    - 
    '''python3
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool
      graph = collections.defaultdict(list)
      # 그래프 구성
      for course, pre in prerequisites:
        graph[course].append(pre)
    
      traced = set()
      # DFS
      def dfs(course):
        # 순환 구조이면 False
        if course in traced:
          return False
    
        traced.add(course)
        for pre in graph[course]:
          if not dfs(pre): # 순환 구조로 하위노드에서 False가 나오면 이어서 False return
            return False
        # 탐색 종류 후 순환 노드 삭제
        traced.remove(course)
    
        return True
    
      # 모든 간선을 탐색하며 순환이 없는지 확인
      for course in list(graph): # graph는 defaultdict로 중간에 값이 변경되어 오류가 발생하므로 list로 감싸 값을 복사하여 탐색 실행
        if not dfs(course): 
          return False
    
      return True
    ```
  - 풀이 2 가지치기를 이용한 최적화
    - 이미 방문했던 노드라면 더 이상 진행하지 않고 True 리턴
    ```python3
    def canFinish(Self, numCourses: int, prerequisites: List[List[int]]) -> bool:
      graph = collections.defaultdict(list)
      # 그래프 구성
      for course, pre in prerequisites:
        graph[course].append(pre)
    
      traced = set()
      visited = set()
    
      # DFS
      def dfs(course):
        # 순환 구조이면 False
        if course in traced:
          return False
    
        # 이미 방문했던 노드이면 True
        if course in visited:
          return True
    
        traced.add(course)
        for pre in graph[course]:
          if not dfs(pre):
            return False
    
        # 탐색 종류 후 순환 노드 삭제
        traced.remove(course)
        # 탐색 종료 후 순환 노드 삭제
        visited.add(course)
    
        return True
      # 모든 간선을 탐색하며 순환이 없는지 확인
      for course in list(graph):
        if not dfs(course):
          return False
          
      return True
    ```
    


    
