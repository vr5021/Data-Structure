# 그래프
  - 객체의 일부 쌍들이 '연관되어' 있는 객체 집합 구조를 말한다.
  - 정점과 간선으로 이루어진다.
# P, NP
| 문제 유형   | 다항 시간 내 풀이 가능? | 다항 시간 내 검증 가능? |
|------------|-----------------|-----------------|
| **P**      | ✅ 가능         | ✅ 가능         |
| **NP**     | ❓ 모르지만, 가능할 수도 있음 | ✅ 가능 |
| **NP-완전** | ❓ 모르지만, 가능할 수도 있음 | ✅ 가능 |
| **NP-난해** | ❓ 모르지만, 가능할 수도 있음 | ❌ 불가능할 수도 있음 |
# 그래프 순회
  - 그래프 탐색이라고도 불리며 그래프의 각 정점을 방문하는 과정을 말한다.
  - 깊이 우선 탐색(DFS, Depth-First Search), 너비 우선 탐색(BFS, Breadth-First Search)의 2가지 알고리즘이 있다.
  - 일반적으로 DFS가 널리 쓰인다.
  - 인접 행렬(Adjacency Matrix)와 인접 리스트(Adjacency List)의 2가지 방법이 있다.
## DFS(깊이 우선 탐색)
  - 재귀 구조로 구현
    ```pseudocode
    DFS(G, v)
      label v as discovered
      for all directed edges from v to w that are in G.adjacentEdges(v) do
          if vertex w is not labeled as discovered then
              recursively call DFS(G, w)
    ```
    ```python3
      def recursive_dfs(v, discovered=[]):
        discovered.append(v)
        for w in graph[v]:
          if w not in discovered:
            discovered = recursive_dfs(w, discovered)
        return discovered
    ```
    - 스택을 이용한 반복 구조로 구현
      ```pseudocode
      DFS-iterative(G, v)
        let S be a stack
        S.push(v)
        while S is not empty do
            v = S.pop()
            if v is not labeled as discovered then
                label v as discovered
                for all edges from v to w in G.adjacentEdges(v) do
                    if w is not labeled as discovered then
                        S.push(w)
        ```
        ```python3
        def iteratice_dfs(start_v):
          discovered = []
          stack = [start_v]
          while stack:
            v = stack.pop()
            if v not in discovered:
              discovered.append(v)
              for w in graph[v]:
                stack.append(w)
          return discovered
        ```
## BFS(너비 우선 탐색)
  - 큐를 이용한 반복 구조로 구현
    ```pseudocode
    BFS(G, root)
      let Q be a queue
      label root as explored
      Q.enqueue(root)
      while Q is not empty do
          v := Q.dequeue()
          if v is the goal then
              return v
          for all edges from v to w in G.adjacentEdges(v) do
              if w is not labeled as explored then
                  label w as explored
                  w.parent := v
                  Q.enqueue(w)
    ```
    ```python3
    def iterative_bfs[start_v]:
      discovered = [start_v]
      queue = [start_v]
      while queue:
        v = queue.pop(0)
        for w in graph[v]:
          if w not in discovered:
            discovered.append(w)
            queue.append(w)
      return discovered
    ```
    - BFS는 재귀로 동작하지 않는다.

# 백트래킹
  -  해결책에 대한 후보를 구축해 나아가다 가능성이 없다고 판단된느 즉시 후보를 포기(Backtrack)해 정답을 찾아가는 범용적인 알고리즘으로 제약 충족 문제(Constraint Satisfaction Problem)에 특히 유용하다.
  -  DFS가 백트래킹에 속한다.
  -  브루트 포스와 유사하지만 좀 더 우아한 방식
  -  트리의 가지치기와 같아서 트리의 탐색 최적화 문제와도 관련이 깊다.
# 제약 충족 문제(Constraint Satisfaction Problem)
  - 수많은 제약 조건을 충족하는 상태를 찾아내는 수학 문제
  - 스도쿠처럼 1에서 9까지 숫자를 한 번만 넣는(제약 조건 충족) 정답(상태)을 찾아내는 모든 문제 유형을 말함
# [섬의 개수](https://leetcode.com/problems/number-of-islands/)
1을 육지로, 0을 물로 가정한 2D 그리드 맵이 주어졌을 때, 섬의 개수를 계산하라.(연결되어 있는 1의 덩어리 개수를 구하라.)
  - 풀이 1 DFS로 그래프 탐색
    - 동서남북이 모두 연결된 그래프로 가정하고 네 방향 각각 DFS 재귀를 이용한 동일한 형태로 탐색
    - 탐색을 끝마치면 1이 증가하는 형태
    ```python3
    def numIslands(self, grid: List[List[str]]) -> int:
      def dfs(i, j):
        # 더 이상 땅이 아닌 경우 종료
        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != '1':
          return
    
        grid[i][j] = 0
    
        # 동서남북 탐색
        dfs(i + 1, j)
        dfs(i - 1, j)
        dfs(i, j + 1)
        dfs(i, j - 1)
    
      count = 0
      for i in range(len(grid)):
        for j in range(len(grid[0])):
          if grid[i][j] == '1':
            dfs(i, j)
            # 모든 육지 탐색 후 카운트 1 증가
            count += 1
      return count
    ```

# [전화 번호 문자 조합](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)
2에서 9까지 숫자가 주어졌을 때 전화 번호로 조합 가능한 모든 문자를 출력하라.
  - 풀이 1 모든 조합 탐색
  ```python3
  def letterCombinations(self, digits: str) -> List[str]:
    def dfs(index, path):
      # 끝까지 탐색하면 백트래킹
      if len(path) == len(digits):
        result.append(path)
        return
  
      # 입력값 자릿수 단위 반복
      for i in range(index, len(digits)):
        # 숫자에 해당하는 모든 문자열 반복
        for j in dic[digits[i]]:
          dfs(i + 1, path + j)
    # 예외 처리
    if not digits:
      return []  
  
    dic = {"2": "abc", "3": "def", "4": "ghi", "5": "jkl", "6": "mno", "7": "pqrs", "8": "tuv", "9": "wxyz"}
    result = []
    dfs(0, "")
    
    return result
  ```

# [순열](https://leetcode.com/problems/permulations/)
서로 다른 정수를 입력받아 가능한 모든 순열을 리턴하라.
  - 풀이 1 DFS를 활용한 순열 생성
    ```python3
    def permute(self, nums: List[int]) -> List[List[int]]:
      result = []
      prev_elements = []
    
      def dfs(elements):
        # 리프 노드일 때 결과 추가
        if len(elements) == 0:
          result.append(elements[:]) 
    
        # 순열 생성 재귀 호출
        for e in elements:
          next_elements = elements[:] # 참조가 아닌 값 복사
          next_elements.remove(e)
          
          prev_elements.append(e)
          dfs(next_elements)
          prev_elements.pop()
      dfs(nums)
      return result
      ```
  - 풀이 2 itertools 모듈 사용
    ```python3
    def permute(self, nums: List[int]) -> List[List[int]]:
      return list(itertools.permulations(nums))
    ```
