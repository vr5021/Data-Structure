# 그래프
  - 객체의 일부 쌍들이 '연관되어' 있는 객체 집합 구조를 말한다.
  - 정점과 간선으로 이루어진다.
# P, NP
| 문제 유형   | 다항 시간 내 풀이 가능? | 다항 시간 내 검증 가능? |
|------------|-----------------|-----------------|
| **P**      | ✅ 가능         | ✅ 가능         |
| **NP**     | ❓ 모르지만, 가능할 수도 있음 | ✅ 가능 |
| **NP-완전** | ❓ 모르지만, 가능할 수도 있음 | ✅ 가능 |
| **NP-난해** | ❓ 모르지만, 가능할 수도 있음 | ❌ 불가능할 수도 있음 |
# 그래프 순회
  - 그래프 탐색이라고도 불리며 그래프의 각 정점을 방문하는 과정을 말한다.
  - 깊이 우선 탐색(DFS, Depth-First Search), 너비 우선 탐색(BFS, Breadth-First Search)의 2가지 알고리즘이 있다.
  - 일반적으로 DFS가 널리 쓰인다.
  - 인접 행렬(Adjacency Matrix)와 인접 리스트(Adjacency List)의 2가지 방법이 있다.
## DFS(깊이 우선 탐색)
  - 재귀 구조로 구현
    ```pseudocode
    DFS(G, v)
      label v as discovered
      for all directed edges from v to w that are in G.adjacentEdges(v) do
          if vertex w is not labeled as discovered then
              recursively call DFS(G, w)
    ```
    ```python3
      def recursive_dfs(v, discovered=[]):
        discovered.append(v)
        for w in graph[v]:
          if w not in discovered:
            discovered = recursive_dfs(w, discovered)
        return discovered
    ```
    - 스택을 이용한 반복 구조로 구현
      ```pseudocode
      DFS-iterative(G, v)
        let S be a stack
        S.push(v)
        while S is not empty do
            v = S.pop()
            if v is not labeled as discovered then
                label v as discovered
                for all edges from v to w in G.adjacentEdges(v) do
                    if w is not labeled as discovered then
                        S.push(w)
        ```
        ```python3
        def iteratice_dfs(start_v):
          discovered = []
          stack = [start_v]
          while stack:
            v = stack.pop()
            if v not in discovered:
              discovered.append(v)
              for w in graph[v]:
                stack.append(w)
          return discovered
        ```
## BFS(너비 우선 탐색)
  - 큐를 이용한 반복 구조로 구현
    ```pseudocode
    BFS(G, root)
      let Q be a queue
      label root as explored
      Q.enqueue(root)
      while Q is not empty do
          v := Q.dequeue()
          if v is the goal then
              return v
          for all edges from v to w in G.adjacentEdges(v) do
              if w is not labeled as explored then
                  label w as explored
                  w.parent := v
                  Q.enqueue(w)
    ```
    ```python3
    def iterative_bfs[start_v]:
      discovered = [start_v]
      queue = [start_v]
      while queue:
        v = queue.pop(0)
        for w in graph[v]:
          if w not in discovered:
            discovered.append(w)
            queue.append(w)
      return discovered
    ```
    - BFS는 재귀로 동작하지 않는다.

# 백트래킹
  -  해결책에 대한 후보를 구축해 나아가다 가능성이 없다고 판단된느 즉시 후보를 포기(Backtrack)해 정답을 찾아가는 범용적인 알고리즘으로 제약 충족 문제(Constraint Satisfaction Problem)에 특히 유용하다.
  -  DFS가 백트래킹에 속한다.
  -  브루트 포스와 유사하지만 좀 더 우아한 방식
  -  트리의 가지치기와 같아서 트리의 탐색 최적화 문제와도 관련이 깊다.
# 제약 충족 문제(Constraint Satisfaction Problem)
  - 수많은 제약 조건을 충족하는 상태를 찾아내는 수학 문제
  - 스도쿠처럼 1에서 9까지 숫자를 한 번만 넣는(제약 조건 충족) 정답(상태)을 찾아내는 모든 문제 유형을 말함
# [섬의 개수](https://leetcode.com/problems/number-of-islands/)
1을 육지로, 0을 물로 가정한 2D 그리드 맵이 주어졌을 때, 섬의 개수를 계산하라.(연결되어 있는 1의 덩어리 개수를 구하라.)
  - 풀이 1 DFS로 그래프 탐색
    - 동서남북이 모두 연결된 그래프로 가정하고 네 방향 각각 DFS 재귀를 이용해 탐색

