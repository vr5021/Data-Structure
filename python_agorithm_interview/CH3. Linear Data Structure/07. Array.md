# 배열
  - 값 도는 변수 엘리먼트의 집합으로 구성된 구조로, 하나 이상의 인덱스 또는 키로 식별된다.
  - 메모리 공간 기반의 연속 방식의 가장 기본이 되는 자료형
## 정적 배열
  - 크기를 지정하고 해당 크기만큼의 연속된 메모리 공간을 할당받는 작업을 수행하는 자료형. 크기가 고정되어 있으며, 한번 생성한 배열은 크기를 변경하는 것이 불가능하다.
  - 메모리 공간 주소는 1바이트마다 1씩 증가하므로 연속된 메모리 공간을 할당받는 특성 상 즉시 주소를 계산할 수 있고 따라서 언제나 O(1)에 조회가 가능하다.
## 동적 배열
  - 크기를 지정하지 않고 자동으로 Resizing하는 배열
  - 미리 초깃값을 작게 잡아 배열을 생성하고, 데이터가 추가되면서 꽉 채워지면, 늘려주고 모두 복사.
  - 재할당 비율을 Growth Factort라 하며 주로 doubling이며 파이썬의 경우는 횟수마다 달라지며 전체적으로는 1.125배이다.
  - 평소에는 O(1)에 조회가 가능하지만 꽉 채워졌을 때 배열 할당과 복사과정에서 O(n)의 시간 복잡도를 가진다.

# [두 수의 합](https://leetcode.com/problems/two-sum/)
  덧셈하여 타겟을 만들 수 있는 배열의 두 숫자 인덱스를 리턴하라.

  - 풀이 1 브루트 포스로 계산(O($n^2$))
    - 배열을 2번 반복하면서 모든 조합을 더해서 일일이 확인해보는 무차별 대입 방식인 Brute-Force 사용
      ```python3
      def twoSum(self, num: List[int], target: int) -> List[int]:
        for i in range(len(nums)):
          for j in range(i + 1, len(nums)):
            if nums[i] + num[j] == target:
                return [i, j]
      ```

  - 풀이 2 in을 이용한 탐색(O($n^2$))
    - 위와 동일한 방식이나 in을 사용한 연산이 훨씬 가볍고 빠르다(상수항 차이)
      ```python3
      def twoSum(self, num: List[int], target: int) -> List[int]:
        for i, n in enumerate(nums):
          complement = target - n

          if complement in nums[i + 1:]:
            return [num.index(n), nums[i + 1:].index(complement) + (i + 1)]
      ```

  - 풀이 3 첫 번째 수를 뺀 결과 키 조회(O(n))
    - 키로 조회
      ```python3
      def twoSum(self, num: List[int], target: int) -> List[int]:
        nums_map = {}
        # 키와 값을 바꿔서 딕셔너리로 저장
        for i, num in enumerate(nums):
          nums_map[num] = i

        # 타겟에서 첫 번째 수를 뺀 결과를 키로 조회
        for i, num in enumerate(nums):
          if target - num in nums_map and i != nums_map[target - num]:
            return [i, nums_map[target -num]]
      ```

  - 풀이 4 조회 구조 계선
    - for 문 최적화
      ```python3
      def twoSum(self, num: List[int], target: int) -> List[int]:
        nums_map = {}
        # 하나의 for 문으로 통합
        for i, num in enumerate(nums):
          if target - num in nums_map 
            return [nums_map[target -num], i]
          nums_map[num] = i
      ```
      
  - 풀이 5 투 포인터 이용
    - 왼쪽 포인터와 오른쪽 포인터의 합이 타겟보다 크다면 오른쪽 포인터를 왼쪽으로, 작다면 왼쪽 포인터를 오른쪽으로 옮기면서 값을 조정
    - 다만 이 경우 정렬된 케이스가 아니므로 적절한 접근 방식이 아니다.
      ```python3
      def twoSum(self, num: List[int], target: int) -> List[int]:
        left, right = 0, len(nums) - 1
        while not left == right:
          # 합이 타겟보다 작으면 왼쪽 포인터를 오른쪽으로
          if nums[left] + nums[right] < target:
            left += 1
          # 합이 타겟보다 크면 오른쪽 포인터를 왼쪽으로
          elif nums[left] + nums[right] > target:
            right -= 1
          else:
            return [left, right]
      ```

# [빗물 트래핑](https://leetcode.com/problems/trapping-rain-water/)
높이를 입력받아 비 온 후 얼마나 많은 물이 쌓일 수 있는지 계산하라
  - 풀이 1 투 포인터를 최대로 이동
    - 최대 높이의 막대까지 각각 좌우 기둥 최대 높이와 현재 높이와의 차이만큼 물 높이 volume을 더해 나간다.
      ```python3
      def trap(self, height: List[int]) -> int:
        if not height:
          return 0
  
        volume = 0
        left, right = 0, len(height) - 1
        left_max, right_max = height[left], height[right]
  
        while left < right:
         left_max, right_max = max(height[left], left_max), 
                               max(height[right], right_max)
          # 더 높은 쪽을 향해 투 포인터 이동
          if left_max <= right_max:
            volume += left_max - height[left]
              left += 1
          else:
              volume += right_max - height[right]
              right -= 1
        return volume
      ```
  - 풀이 2 스택 쌓기
    - 스택에 쌓아 나가면서 현재 높이가 이전 높이보다 높을 때마다(Infelction Point) 부분 변속점을 기준으로 격차만큼 물 높이 volume을 채운다.
    - while 조건문으로 현재 막대가 스택의 마지막 막대보다 큰 동안이므로 while 구문 내로 들어가지 않고 그동안 스택에 채워진 막대는 왼쪽 경계 막대보다 계속 작거나 같은 높이의 막대
    - 따라서 while 구문에 들어간 이상 형성된 왼쪽 막대와 오른쪽 막대보다 그 사이에 있는 막대들(stack 내)은 왼쪽에서 오른쪽으로 내려가는 계단 형식의 배열
    - 경계 사이의 가장 낮은 막대가 top = stack.pop()으로 차례대로 튀어나오고 water를 계산할때 경계중 낮은 경계를 기준으로 계산되므로 가장 낮은 막대인 top이 낮은 경계의 높이와 같다면 water = 0 으로 계산되고
    - 이전 왼쪽 경계 막대를 기준으로 반복문이 재동작한다.
      ```python3
      def trap(self, height: List[int]) -> int:
        stack = []
        volume = 0
        for i in range(len(height)):
          # 변곡점을 만나는 경우
          while stack and height[i] > height[stack[-1]]:
            # 스택에서 꺼낸다.
            top = stack.pop()
  
            if not len(stack):
              break
  
            # 이전과의 차이만큼 물 높이 처리
            distance = i - stack[-1] - 1
            waters = min(height[i], ehight[stack[-1]]) - height[top]
  
            volume += distance * waters
  
          stack.append(i)
        return volume
      ```
# [세 수의 합](https://leetcode.com/problems/3sum/)
배열을 입력받아 합으로 0을 만들 수 잇는 3개의 엘리먼트를 출력하라
  - 풀이 1 브루트 포스로 계산
    - sort를 사용해 O(nlog n)으로 정렬 후 브루트 포스로 계산
    - 중복된 값은 continue로 건너뛰기
    ```python3
    def threeSum(self, nums: List[int]) -> List[List[int]]:
      results = []
      nums.sort()

      # 브루트 포스 n^3 반복
      for i in range(len(nums) - 2):
        # 중복된 값 건너뛰기
        if i > 0 and nums[i] == nums[i -1]:
          continue
        for j in range(i + 1, len(nums) -1):
          if j > i + 1 and nums[j] == nums[j -1]:
            continue
          for k in range(j + 1, len(nums)):
            if k > j + 1 and nums[k] == nums[k -1]:
              continue
            if nums[i] + nums[j] + nums[k] == 0:
              results.append([nums[i], nums[j], nums[k]])
      return results
    ```
- 풀이 2 투 포인터로 합 계산
  - 같은 값은 건너뛰기 위해 for문
  - sum이 0보다 작으면 left를 우측으로, 크면 right을 왼쪽으로 이동하여 sum이 0일 때 results에 추가
  - 추가한 뒤 양옆에 동일한 값이 있을 수 있으므로 left += 1, right -= 1 반복하여 스킵 처리
    ```python3
    def threeSum(self, nums: List[int]) -> List[List[int]]:
      results = []
      nums.sort()

      for i in range(len(nums) - 2):
        # 중복된 값 건너뛰기
        if i > 0 and nums[i] == nums[i -1]:
          continue

        # 간격을 좁혀가며 합 sum 계산
        left, right = i + 1, len(nums) - 1
        while left < right:
          sum = nums[i] + nums[left] + nums[right]
          if sum < 0:
            left +=1
          elif sum > 0:
            right -= 1
          else:
            # sum = 0인 경우이므로 정답 및 스킵 처리
            results.append([nums[i], nums[left], nums[right]])

            while left < right and nums[left] == nums[left + 1]:
              left += 1
            while left < right and nums[right] == nums[right - 1]:
              right -= 1
            left += 1
            right -= 1
    
      return results
    ```

# [배열 파티션 I](https://leetcode.com/problems/array-partition-i/)
n 개의 페어를 이용한 min(a, b)의 합으로 만들 수 잇는 가장 큰 수를 출력하라.
  - 풀이 1 오름차순 풀이
    - min 자체도 커야함
    - 뒤에서부터 내림차순으로 집어넣으면 항상 최대 min() 페어 유지
    ```python3
    def arrayPairSum(self, nums: List[int]) -> int:
      sum = 0
      pair = []
      nums.sort()

      for n in nums:
        # 앞에서부터 오름차순으로 페어를 만들어서 합 계산
        pair.append(n)
        if len(pair) == 2:
          sum += min(pair)
          pair = []

      return sum
    ```
- 풀이 2 짝수 번째 값 계산
    ```python3
    def arrayPairSum(self, nums: List[int]) -> int:
      sum = 0
      nums.sort()

      for i,n in enumerate(nums):
        # 짝수 번째 값의 합 계산
        if i % 2 == 0:
          sum += n
      return sum
    ```
- 풀이 3 파이썬다운 방식
    ```python3
    def arrayPairSum(self, nums: List[int]) -> int:
      return sum(sorted(nums)[::2])
    ```
# [자신을 제외한 배열의 곱](https://leetcode.com/problems/product-of-array-except-self/)
배열을 입력받아 output[i]가 자신을 제외한 나머지 모든 요소의 곱셈 결과가 되도록 출력하라.
나눗셈을 하지 않고 O(n)에 풀이하라.
  - 풀이 1 왼쪽 곱셈 결과에 오른쪽 값을 차례대로 곱셈
    - 주어진 배열의 처음부터 끝까지 순회하며 현재 값의 왼쪽에 있는 값들의 곱들을 가지는 배열 생성
    - 현재 값의 오른쪽에 있는 값들의 곱들을 위 배열에 각각 곱셈
    ```python3
    def productExceptSelf(self, nums: List[int]) -> List[int]:
      out = []
      p = 1
      # 왼쪽 곱셈
      for i in range(0, len(nums)):
        out.append(p)
        p = p * nums[i]
      p = 1
      # 왼쪽 곱셈 결과에 오른쪽 값을 차례대로 곱셈
        for i in range(len(nums) - 1, -1, -1):
          out[i] = out[i] * p
          p = p * nums[i]
      return out
    ```
# [주식을 사고팔기 가장 좋은 시점](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)
한번의 거래로 낼 수 있는 최대 이익을 산출하라.
  - 풀이 1 브루트 포스로 계산
    ```python3
    def maxProfit(slef, prices: List[int]) -> int:
      max_price = 0
      for i, price in enumerate(prices):
        for j in range(i, len(prices)):
          max_price = max(price[j] - price, max_price)
  
      return max_price
    ```
- 풀이 2 저점과 현재 값과의 차이 계산
  - 순회해 나가며 최저점을 갱신하고 현재와 고점과의 차이를 확인한다.
  ```python3
    def maxProfit(self, prices: List[int]) -> int:
      profit = 0
      min_price = sys.maxsize

      # 최솟값과 최댓값을 계속 갱신
      for price in prices:
        min_price = min(min_price, price)
        profit = max(profit, price - min_price)

      return profit
  ```
    
        
