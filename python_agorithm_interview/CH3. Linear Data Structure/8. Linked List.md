# 연결 리스트
- 데이터 요소의 선형 집합으로, 데이터의 순서가 메모리에 물리적인 순서대로 저장되지는 않는다.
- 배열과 함께 가장 기본이 되는 대표적인 선형 자료구조 중 하나로 다양한 ADT 구현의 기반이 된다.
- 데이터를 구조체로 묶어 포인터로 연결하기 때문에 구조체 각각이 서로 연결된 형태로 메모리 어딘가에 여기저기 흩뿌려진 형상을 띤다.
- 배열과 달리 상수 시간에 조회할 수 없어 시작 또는 끝 지점 외에 O(n)이 소요된다.

# [팬린드롬 연결 리스트](https://leetcode.com/problems/palindrome-linekd-list/)
연결 리스트가 팰린드롬 구조인지 판별하라
  - 풀이 1 리스트 변환
    ```python3
    def isPalindrome(self, head: ListNode) -> bool:
      q: List = []

      if not head:
        return True

      node = head
      # 리스트 변환
      while node is not None:
        q.append(node.val)
        node = node.next

      # 팰린드롬 판별
      while len(q) > 1:
        if q.pop(0) != q.pop():
          return False

      return True
    ```
  - 풀이 2 데크를 이용한 최적화
    - 동적 배열은 첫번째 아이템을 가져오면 모든 값이 한 칸씩 shifting 되어 O(n)이 발생하기 때문에 최적화를 위해 맨 앞의 데이터를 가져올 때 O(n)이내에 처리할 수 있는 자료형인 Deque가 적합하다.
    - 데크는 이중 연결 리스트 구조로 양쪽 방향 모두 추출하는 데 O(1)에 실행된다.
      - 이중 연결 리스트는 각 노드가 값, 앞 노드 , 뒤 노드를 가지고 있는 구조로 새로운 노드를 추가하거나 제거할 때 기존 노드의 포인터만 변경하면 된다.
    ```python3
    def isPalindrome(self, head: ListNode) -> bool:
      # 데크 자료형 선언
      q: Deque = collections.deque()

      if not head:
        return True

      node = head
      # 리스트 변환
      while node is not None:
        q.append(node.val)
        node = node.next

      # 팰린드롬 판별
      while len(q) > 1:
        if q.popleft() != q.pop():
          return False

      return True
    ```
  - 풀이 3 Runner를 이용한 우아한 풀이
    - 연결 리스트를 순회할 때 2개의 포인터를 동시에 사용하여 한 포인터가 다른 포인터보다 앞서게 하여 병합 지점이나 중간 위치, 길이 등을 판별할 대 유용하게 사용할 수 있다.
    - 모두 head에서 시작하여 속도를 두배 차이나게 하면 빠른 러너가 끝에 도달할 때 느린 러너는 중간지점에 도착한다.
    - 느린 러너가 중간 지점에 도착 할 때까지 역순으로 연결 리스트 rev를 만들어 나간다.
    - 중간에 느린 러너가 도착하면 나머지 절반을 느린 러너가 지나가면서 만들어진 역순 연결 리스트 rev와 비교해나가면 된다.
    ```python3
    def isPalindrome(self, head: ListNode) -> bool:
      rev = none
      slow = fast = head
      # 러너를 이용해 역순 리스트 구성
      while fast and fas.next:
        fast = fast.next.next
        rev, rev.next, slow = slow, rev, slow.next
      if fast:
        slow slow.next

      # 팰린드롬 여부 확인
      while rev and rev.val == slow.val:
        slow, rev = slow.next, rev.next
      return not rev
    ```
      - 위와 같이 다중 할당 문법을 사용한 것은 원시 타입이 존재하지 않고 불변 객체에 대해 서로 같은 값을 참조하게 되는 파이썬의 특징에 따라서 동일한 참조가 이뤄지지 않기 위함이다.
# [두 정렬 리스트의 병합](https://leetcode.com/problems/merge-two-sorted-lists/)
정렬되어 있는 두 연결 리스트를 합쳐라.
  - 풀이 1 재귀 구조로 연결
    
