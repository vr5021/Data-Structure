# 트라이
검색 트리의 일종으로 일반적으로 키가 문자열인 동적 배열 또는 연관 배열을 저장하는 데 사용되는 정렬된 트리 자료구조다.        
각각의 문자 단위로 색이늘 구축한 것과 유사하다.       
![image](https://github.com/user-attachments/assets/93bd4e65-9a07-4462-bcd3-6ae189aa6fc3)
# [트라이 구현](https://leetcode.com/problems/implement-trie-prefix-tree)
트라이의 insert, search, startWith 메소드를 구현하라.
 - 풀이 1 딕셔너리를 이용해 간결한 트라이 구현
   ```python3
   class TrieNode:
      def __init__(self):
          self.word = False
          self.children = collections.defaultdict(TrieNode)
  
    class Trie:
        def __init__(self):
            self.root = TrieNode()
    
        # 단어 삽입
        def insert(self, word: str) -> None:
            node = self.root
            for char in word:
                node = node.children[char]
            node.word = True
        
        # 단어 존재 여부 판별
        def search(self, word: str) -> bool:
            node = self.root
            for char in word:
                if char not in node.children:
                    return False
                node = node.children[char]
            return node.word
    
        # 문자열로 시작 단어 존재 여부 판별
        def startsWith(self, prefix: str) -> bool:
            node = self.root
            for char in prefix:
                if char not in node.children:
                    return False
                node = node.children[char]
            return True
    ```

# [팰린드롬 페어](https://leetcode.com/problems/palindrome-pairs)
단어 리스트에서 words[i] + words[j]가 팰린드롬이 되는 모든 인덱스 조합 (i, j)를 구하라.
  - 풀이 1 팰린드롬을 브루트 포스로 계산
    ```python3
    def palindromePairs(self, words: List[str]) -> List[List[int]]:
      def is_palindrome(word):
          return word == word[::-1]
  
      output = []
      for i, word1 in enumerate(words):
          for j, word2 in enumerate(words):
              if i == j:
                  continue
              if is_palindrome(word1 + word2):
                  output.append([i, j])
      return output
    ```
  - 풀이 2 트라이 구현
    ```python3
    # 트라이를 저장할 노드
    class TrieNode:
      def __init__(self):
          self.children = collections.defaultdict(TrieNode)
          self.word_id = -1
          self.palindrome_word_ids = []
  
    class Trie:
        def __init__(self):
            self.root = TrieNode()
    
        @staticmethod
        def is_palindrome(word: str) -> bool:
            return word[::] == word[::-1]
    
        # 단어 삽입
        def insert(self, index, word) -> None:
            node = self.root
            for i, char in enumerate(reversed(word)):
                if self.is_palindrome(word[0:len(word) - i]):
                    node.palindrome_word_ids.append(index)
                node = node.children[char]
                node.val = index
            node.word_id = index
    
        def search(self, index, word) -> List[List[int]]:
            result = []
            node = self.root
    
            while word:
                # 판별 로직 3
                if node.word_id >= 0:
                    if self.is_palindrome(word):
                        result.append([index, node.word_id])
    
                if not word[0] in node.children:
                    return result
                node = node.children[word[0]]
                word = word[1:]
    
            # 판별 로직 1
            if node.word_id >= 0 and node.word_id != index:
                result.append([index, node.word_id])
    
            # 판별 로직 2
            for palindrome_word_id in node.palindrome_word_ids:
                result.append([index, palindrome_word_id])
    
            return result
    
      class Solution:
          def palindromePairs(self, words: List[str]) -> List[List[int]]:
              trie = Trie()
              for i, word in enumerate(words):
                  trie.insert(i, word)
      
              results = []
              for i, word in enumerate(words):
                  results.extend(trie.search(i, word))
      
              return results
    ```

### @staticmethod 데코레이터
  - java의 static 선언처럼 클래스 인스턴스에 접근이 불가한 클래스 외부의 독립된 함수와 같은 의미를 가진다.
  - 따라서 클래스 인스턴스에 접근을 제한하고 분명하게 독립적인 함수로 선언하고자 할 경우 종종 사용된다.
