# 연결 리스트
- 데이터 요소의 선형 집합으로, 데이터의 순서가 메모리에 물리적인 순서대로 저장되지는 않는다.
- 배열과 함께 가장 기본이 되는 대표적인 선형 자료구조 중 하나로 다양한 ADT 구현의 기반이 된다.
- 데이터를 구조체로 묶어 포인터로 연결하기 때문에 구조체 각각이 서로 연결된 형태로 메모리 어딘가에 여기저기 흩뿌려진 형상을 띤다.
- 배열과 달리 상수 시간에 조회할 수 없어 시작 또는 끝 지점 외에 O(n)이 소요된다.

# [팬린드롬 연결 리스트](https://leetcode.com/problems/palindrome-linekd-list/)
연결 리스트가 팰린드롬 구조인지 판별하라
  - 풀이 1 리스트 변환
    ```python3
    def isPalindrome(self, head: ListNode) -> bool:
      q: List = []

      if not head:
        return True

      node = head
      # 리스트 변환
      while node is not None:
        q.append(node.val)
        node = node.next

      # 팰린드롬 판별
      while len(q) > 1:
        if q.pop(0) != q.pop():
          return False

      return True
    ```
  - 풀이 2 데크를 이용한 최적화
    - 동적 배열은 첫번째 아이템을 가져오면 모든 값이 한 칸씩 shifting 되어 O(n)이 발생하기 때문에 최적화를 위해 맨 앞의 데이터를 가져올 때 O(n)이내에 처리할 수 있는 자료형인 Deque가 적합하다.
    - 데크는 이중 연결 리스트 구조로 양쪽 방향 모두 추출하는 데 O(1)에 실행된다.
      - 이중 연결 리스트는 각 노드가 값, 앞 노드 , 뒤 노드를 가지고 있는 구조로 새로운 노드를 추가하거나 제거할 때 기존 노드의 포인터만 변경하면 된다.
    ```python3
    def isPalindrome(self, head: ListNode) -> bool:
      # 데크 자료형 선언
      q: Deque = collections.deque()

      if not head:
        return True

      node = head
      # 리스트 변환
      while node is not None:
        q.append(node.val)
        node = node.next

      # 팰린드롬 판별
      while len(q) > 1:
        if q.popleft() != q.pop():
          return False

      return True
    ```
  - 풀이 3 Runner를 이용한 우아한 풀이
    - 연결 리스트를 순회할 때 2개의 포인터를 동시에 사용하여 한 포인터가 다른 포인터보다 앞서게 하여 병합 지점이나 중간 위치, 길이 등을 판별할 대 유용하게 사용할 수 있다.
    - 모두 head에서 시작하여 속도를 두배 차이나게 하면 빠른 러너가 끝에 도달할 때 느린 러너는 중간지점에 도착한다.
    - 느린 러너가 중간 지점에 도착 할 때까지 역순으로 연결 리스트 rev를 만들어 나간다.
    - 중간에 느린 러너가 도착하면 나머지 절반을 느린 러너가 지나가면서 만들어진 역순 연결 리스트 rev와 비교해나가면 된다.
    ```python3
    def isPalindrome(self, head: ListNode) -> bool:
      rev = none
      slow = fast = head
      # 러너를 이용해 역순 리스트 구성
      while fast and fas.next:
        fast = fast.next.next
        rev, rev.next, slow = slow, rev, slow.next
      if fast:
        slow = slow.next

      # 팰린드롬 여부 확인
      while rev and rev.val == slow.val:
        slow, rev = slow.next, rev.next
      return not rev
    ```
      - 위와 같이 다중 할당 문법을 사용한 것은 원시 타입이 존재하지 않고 불변 객체에 대해 서로 같은 값을 참조하게 되는 파이썬의 특징에 따라서 동일한 참조가 이뤄지지 않기 위함이다.
# [두 정렬 리스트의 병합](https://leetcode.com/problems/merge-two-sorted-lists/)
정렬되어 있는 두 연결 리스트를 합쳐라.
  - 풀이 1 재귀 구조로 연결
  ```python3
  def mergeTwoLists(self, l1:ListNode, l2: ListNode) -> ListNode:
    if (not l1) or (l2 and l1.val > l2.val): # 작은 값이 왼쪽에 오게 한다(l1).
      l1, l2 = l2, l1
    if l1:
      l1.next = self.mergeTwoLists(l1.next, l2) # 재귀적으로 l1 다음의 노드와 l2을 요소로 하여 함수를 호출하여 그 다음으로 작은 값이 l1의 다음이 되도록 연속한다.
    return l1
  ```
    - 연산자 우선 순위: 비교연산자, and, or 순서
    
# [역순 연결 리스트](https://leetcode.com/problems/reverse-linked-list/)
연결 리스트를 뒤집어라
  - 풀이 1 재귀 구조로 뒤집기
    - 다음 노드와 현재 노드를 파라미터로 지정한 함수를 계속해서 재귀 호출
    - node.next에 이전 prev 리스트를 계속 연결해주면서 node가 Node이 될 때가지 재귀 호출
    ```python3
    def reverseList(self, head: ListNode) -> ListNode:
        def reverse(node: ListNode, prev: ListNode = None):
          if not node:
            return prev
          next, node.next = node.next, prev
          return reverse(next, node)
      return reverse(head)
    ```
  - 풀이 2 반복 구조로 뒤집기
    ```python3
    def reverseList(self, head: ListNode) -> ListNode:
      node, prev = head, None

      while node:
        next, node.next = node.next, prev
        prev, node = node, next

      return prev
    ```
      - 반복이 좀 더 빠르고 공간 복잡도도 낮음
# [두 수의 덧셈](https://leetcode.com/problems/add-two-numbers/)
역순으로 저장된 연결 리스트의 숫자를 더하라
  - 풀이 1 자료형 변환
  - 역순으로 뒤집고 리스트로 변환, 다시 연결 리스트로 변경
  ```python3
  class Solution:
    # 연결 리스트 뒤집기
    def reverseList(self, head: ListNode) -> ListNode:
      node, prev = head, None
  
      while node:
        next, node.next = node.next, prev
        prev, node = node, next
      return prev
  
    # 연결 리스트를 파이썬 리스트로 변환
    def toList(self, node:ListNode) -> List:
      list: List = []
      while node:
        list.append(node.val)
        node = node.next
      return list
  
    # 파이썬 리스트를 연결 리스트로 변환
    def toReverseLinkedList(self, result: str) -> ListNode:
      prev: ListNode = None
      for r in result:
        node = ListNode(r)
        node.next = prev
        prev = node
  
      return node
  
    # 두 연결 리스트의 덧셈
    def addTwoNumvers(self, l1: ListNode, l2: ListNode) -> ListNode:
      a = self.toList(self.reverseList(l1))
      b = self.toList(self.reverseList(l2))
  
      resultStr = int(''.join(str(e) for e in a)) + \
                  int(''.join(str(e) for e in b))
  
      # 최종 계산 결과 연결 리스트 변환
      result self.toReverseLinkedList(str(resultStr))
  ```

# [페어의 노드 스왑](https://leetcode.com/problems/add-two-numbers/)
연결 리스트를 입력받아 페어 단위로 스왑하라.
  - 풀이 1 값만 교환
    ```python3
    def swapPairs(self, head: Listnode) -> ListNode:
      cur = head
      while cur and cur.next:
        # 값만 교환
        cur.val, cur.next.val = cur.next.val, cur.val
        cur = cur.next.next
      return head
    ```
  - 풀이 2 반복 구조로 스왑
    - a의 다음이 b일때 b가 a를 가리키고 a는 b의 다음을 가리키도록 함
    - a의 이전 노드가 b를 가리키게 하고 다음 비교를 위해 이전 노드를 두 칸 앞으로 이동
      ```python3
      def swapPairs(self, head: Listnode) -> ListNode:
        root = prev = ListNode(None)
        prev.next = head
        while head and head.next:
          # b가 a(head)를 가리키도록 할당
          b = head.next
          head.next = b.next
          b.next = head
  
          # prev가 b를 가리키도록 할당
          prev.next = b
  
          # 다음번 비교를 위해 이동
          head = head.next
          prev = prev.next.next
        return root.next
      ```
    - 재귀 구조로 스왑
      ```python3
      def swapPairs(self, head: Listnode) -> ListNode:
        if head and head.next:
          p = head.next
          # 스왑된 값 리턴 받음
          head.next = self.swapPairs(p.next)
          p.next = head
          return p
      return head
      ```
# [홀짝 연결 리스트](https://leetcode.com/problems/odd-even-linked-list/)
연결 리스트를 홀수 노드 다음에 짝수 노드가 오도록 재구성하라. 공간 복잡도 O(1), 시간 복잡도O(n)에 풀이하라.
  - 풀이 1 반복 구조로 홀짝 노드 처리
    ```python3
    def offEvenList(self, head: ListNode) -> ListNode:
      # 예외 처리
      if head is None:
        return None

      odd = head
      even = head.next
      even_head = head.next

      # 반복하면서 홀짝 노드 처리
      while even and even.next:
        odd.next, even.next = odd.next.next, even.next.next
        odd, next = odd.next, even.next

      # 홀수 노드의 마지막을 짝수 헤드로 연결
      odd.next = even_head
      return head
    ```
# [역순 연결 리스트 II](https://leetcode.com/problems/reverse-linked-list-ii/)
인덱스 m에서 n까지를 역순으로 만들어라. 인덱스 m은 1부터 시작한다.
  - 풀이 1 반복 구조로 노드 뒤집기
    ```python3
    def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:
      # 예외 처리
      if not head or m == n:
        return head

      root = start = ListNode(None)
      root.next = head
      # start, end 지정
      for _ in range(m - 1):
        start = start.next
      end = start.next

      # 반복하면서 노드 차례대로 뒤집기
      for _ in range(n - m):
        tmp, start.next, end.next = start.next, end.next, end.next.next
        start.next.next = tmp
      return root.next
    ```
