# 데크
  - Double-Ended Queue의 줄임말로, 글자 그대로 양쪽 끝을 모두 추출할 수 있는 큐를 일반화한 형태의 추상 자료형이다.
  - 스택과 큐의 특징을 모두 갖고 있으며 이중 연결 리스트로 구현하는 편이 가장 잘 어울린다.
  - head와 tail이라는 이름의 두 포인터를 갖고 있다.
# [원형 데크 디자인](https://leetcode/problems/design-circular-deque/)
다음 연산을 제공하는 원형 데크를 디자인하라.     
MyCircularDeque(k): 데크 사이즈를 k로 지정하는 생성사.    
insertFropnt(): 데크 처음에 아이템을 추가하고 성공할 경우 true return.     
insertLast(): 데크 마지막에 아이템을 추가하고 성공할 경우 true return.     
deleteFront(): 데크 처음에 아이템을 삭제하고 성공할 경우 true return.     
deleteLast(): 데크 마지막에 아이템을 삭제하고 성공할 경우 true return.    
getFront: 데크의 첫 번째 아이템을 가져온다. 데크가 비어 있다면 -1 return.    
getRear(): 데크의 마지막 아이템을 가져온다. 데크가 비어 있다면 -1 return.     
isEmpty(): 데크가 비어 있는지 여부 판별.      
isFull(): 데크가 가득 차 있는지 여부를 판별한다.       
  - 풀이 1 이중 연결 리스트를 이용한 데크 구현
    ``` python3
    class MyCircularDeque:
      def __init__(self, k: int):
        self.head, self.tail = ListNode(None), ListNode(None)
        self.k, self.len = k, 0
        self.head.right, self.tail.left = self.tail, self.head

      # 이중 연결 리스트에 신규 노드 삽입
      # node, n은 기존 노드(node->new->n), n은 더미 노드라고 봐야하는 듯
      def _add(self, node: ListNode, new: ListNode):
        n = node.right # n: 현재 노드 오른쪽 포인터
        node.right = new # 현재 노드 오른쪽에 new 할당
        new.left, new.right = node, n # 새 노드 왼쪽(현재 노드) 오른쪽 연결(포인터)
        n.left = new(오른쪽 노드 기준 왼쪽(새 노드)과 연결)

      def _del(self, node: ListNode):
        n = node.right.right
        node.right = n
        n.left = node

      def insertFront(self, value: int) -> bool:
        if self.len == self.k:
          return False
        self.len += 1
        self._add(self.head, ListNode(value))
        return True
  
      def insertLast(self, value: int) -> bool:
        if self.len == self.k:
          return False
        self.len += 1
        self._add(self.tail.tail.left, ListNode(value))
        return True
  
      def deleteFront(self) -> bool:
        if self.len == 0:
          retrun False
        self.len -= 1
        self._del(Self.head)
        return True
  
      def deleteLast(self) -> bool:
        if self.len == 0:
          return False:
          self.len -= 1
          self._del(self.tail.left.left)
          return True

      def getFront(self) -> int:
        return self.head.right.val if self.len else -1

      def getRear(self) -> int:
        return self.tail.left.val if self.len else -1

      def isEmpty(self) -> bool:
        return self.len == 0

      def isFull(self) -> bool:
        return self.len == self.k
    ```

# 우선순위 큐
  - 큐 또는 스택과 같은 추상자료형과 유사하지만 추가로 각 요소의 '우선순위'와 연관되어 있다.
  - 입력 순서와 달리 특정 조건에 다라 우선순위가 가장 높은 요소가 추출되는 자료형

# [k개 정렬 리스트 병합](https://leetcode/problems/merge-k-sorted-lists/)
k개의 정렬된 리스트를 1개의 정렬된 리스트로 병합하라.

- 풀이 1 우선순위 큐를 이요한 리스트 병합
  ```python3
  def mergerKLists(self, lists: List[ListNode]) -> ListNode:
    root = result = ListNode(Node)
    heap = []

    # 각 연결 리스트의 루트를 힙에 저장
    for i in range(len(lists)):
      if lists[i]:
        heapq.heappush(heap, lists[i].val, i, lists[i]))

    # 힙 추출 이후 다음 노드는 다시 저장
    while heap:
      node = heapq.heappop(heap)
      idx = node[1]
      result.next = node[2]

      result = result.next
      if result.next:
        heapq.heappush(heap, (result.next.val, idx, result.next))

    return root.next
  ```
  
