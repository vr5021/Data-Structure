# 해시 테이블
  - 키를 값에 매핑할 수 있는 구조인, 연관 배열 ADT를 구현하는 자료구조다.
  - O(1)

# 해시
  - 해시 함수: 임의 크기 데이터를 고정 크기 값으로 매핑하는 데 사용할 수 있는 함수     
    ![image](https://github.com/user-attachments/assets/23426682-a990-4304-a793-2696157feef1)     
    입력값 크기에 상관 없이 크기가 고정된다.
  - 해싱: 해시 테이블 을 인덱싱하기 위해 해시 함수를 사용하는 것, 검색, 심볼 테이블 등의 자료구조 구현에 적합하다.
  - 좋은 해시 함수
      1. 해시 함수 값 충돌 최소화
      2. 쉽고 빠른 연산
      3. 해시 테이블 전체에 해시 값이 균일하게 분포
      4. 사용할 키의 모든 정보를 이용하여 해싱
      5. 해시 테이블 사용 효율이 높을 것
## 생일 문제
  - 실제로 일년 내 365일 중 생일이 같을 확률은 사람의 수는 23명만 있어도 확률이 50%를 넘어설 정도로 충돌은 쉽게 일어난다.
## 비둘기집 원리
  - 비둘기집이 9개 있을 때 비둘기가 10마리 들어온다면 반드시 1번 이상은 충돌이 발생하게 된다.
  - 좋은 해시 함수라면 충돌은 1번이지만 최악의 경우 9번 발생해서 9개의 공간 중 1개밖에 사용하지 못하게 된다.
## 로드 팩터
  - 해시 테이블에 저장된 데이터 개수 N을 버킷의 개수 K로 나눈 것
    $$load\ factor = \frac{n}{k}$$
  - 0.75정도가 적절하며 로드 팩터가 증가할 수록 해시 테이블의 성능은 점점 감소하게 된다.
## 해시 함수
  - 나눗셈 방식
    - $$h(x) = xmodm$$
      - x: 입력값, 간단한 규칙을 통해 만들어낸 랜덤한 상태의 키의 값            
        ![image](https://github.com/user-attachments/assets/7def117b-3110-4490-b8e2-8bf70002d9f0)       
        x = 31 일때 가장 계산 비용이 낮다.       

      - m: 해시 테이블의 크기, 2의 멱수에 가깝지 않은 소수를 택하는 것이 좋다.
  - 딥러닝을 이용한 학습 모델로 충돌을 최소화 하는 방법도 존재한다.
# 충돌
  - 아무리 좋은 함수 라도 충돌은 발생하므로 이를 처리하는 방법이 필요하다.
## 개별 체이닝
  - 해시 테이블의 기본 방식으로 충돌 발생 시 연결 리스트로 연결하는 방식
    - 1. 키의 해시 값을 계산한다.
      2. 해시 값을 이용해 배열의 인덱스를 구한다.
      3. 같은 인덱스가 있다면 연결 리스트로 연결한다.
  - 잘 구현한 경우 O(1), 최악의 경우로 모든 해시 충돌이 발생했을 경우 O(n)
## 오픈 어드레싱
  - 충돌 방생 시 탐사를 통해 빈 공간을 찾아나서는 방식
  - 무한정 저장이 가능한 체이닝 방식과 달리 전체 슬롯의 개수 이상은 저장할 수 없다.
  - 충돌이 일어나면 탐사를 통해 빈 공간을 찾아 해결하므로 모든 원소가 반드시 자신의 해시값과 일치하는 주소에 저장된다는 보장은 없다.
    - 선형 탐사
      - 충돌이 발생할 경우 그 다음 위치를 확인해 빈 공간일 경우 삽입
      - 저장되는 데이터가 고르게 분포되지 않고 뭉치는 클러스터링 현상이 발생하는 문제점이 있다.
  - 기준이 되는 로드 팩터 비율을 넘어서게 되면 Growth Factor의 비율에 따라 더 큰 크기의 또 다른 버킷을 생성한 후 여기에 새롭게 복사하는 Rehashing 작업이 일어난다.(동적 배열과 유사)
## 언어별 해시 테이블 구현 방식
  - 파이썬은 딕셔너리가 해시 테이블로 구현된 자료형으로 오픈 어드레싱 방법으로 구현되어 있다.
  - 체이닝 시 추가 메모리 할당이 느린 작업으로 채택을 안 했다.

# [해시맵 디자인](https://leetcode.com/problems/design-hashmap/)
다음의 기능을 제공하는 해시맵을 디자인하라.
put(key, value): 키, 값을 해시맵에 삽입한다. 만약 이미 존재하는 키라면 업데이트한다.     
get(key): 키에 해당하는 값을 조회한다. 만약 키가 존재하지 않는다면 -1을 리턴한다.      
remove(key): 키에 해당하는 키, 값을 해시맵에서 삭제한다.      
  - 풀이 1 개별 체이닝 방식을 이용한 해시 테이블 구현
  ```python3
  class MyHashMap:
    
    def __init__(self):
      self.size = 1000
      self.table = collections.defaultdict(ListNode)
  
    def put(self, key: int, value: int) -> None:
      index = key % self.size
      # 인덱스에 노드가 없다면 삽입 후 종료
      if self.table[index].value is None:
        self.table[index] = ListNode(key, value)
        return
  
      # 인덱스에 노드가 존재하는 경우 연결 리스트 처리
      p = self.table[index]
      while p:
        if p.key == key:
          p.value = value
          return
        if p.next is None:
          break
        p = p.next
      p.next = ListNode(key, value)
  
    def get(self, key: int) -> int:
      index = key % self.size
      if self.table[index].value is None:
        return -1
  
      # 노드가 존재할 때 일치하는 키 탐색
      p = self.table[index]
      while p:
        if p.key == key:
          return p.value
        p = p.next
      return -1
  
    def remove(self, key: int) -> None:
      index = key % self.size
      if self.table[index].value is None:
        return
  
      # 인덱스의 첫 번째 노드일 때 삭제 처리
      p = self.table[index]
      if p.key == key:
        self.table[index] = ListNode() if p.next is None else p.next
        return
  
      # 연결 리스트 노드 삭제
      prev = p
      while p:
        if p.key == key:
          prev.next = p.next
          return
        prev, p = p, p.next
  ```
# [보석과 돌](https://leetcode.com/problems/jewels-and-stones/)
J는 보석이며 S는 갖고 있는 돌이다. S에는 보석이 몇 개나 있을까? 대소문자는 구분한다.
  - 풀이 1 해시 테이블을 이용한 풀이
  ```python3
  def numJewelsInStones(J: str, S: str) -> int:
    freqs = {}
    count = 0
  
    # 돌(S)의 빈도 수 계산
    for char in S:
      if char not in freqs:
        freqs[char] = 1
      else:
        freqs[char] += 1
  
    # 보석(J)의 빈도 수 합산
    for char in J:
      if char in freqs:
        count += freqs[char]
  
    return count
  ```
  - 풀이 2 defaultdict를 이용한 비교 생략
  ```python3
  def numJewelsInStones(J: str, S: str) -> int:
    freqs = collections.defaultdict(int)
    count = 0
  
    # 비교 없이 보석 빈도 수 계산
    for char in S:
      freqs[char] += 1
  
    # 비교 없이 보석 빈도 수 합산
    for char in J:
      count += freqs[char]
  
    return count
  ```
  - 풀이 3 Counter로 계산 생략
  ```python3
  def numJewelsInStones(J: str, S: str) -> int:
      freqs = collections.Counter(S) # 돌(S) 빈도 수 계산
      count = 0
      for char in J:
          count += freqs[char]
      return count
  ```
  - 풀이 4 파이썬다운 방식
  ```python3
  def numJewelsInStones(J: str, S: str) -> int:
    return sum(s in J for s in S)
  ```
# [중복 문자 없는 가장 긴 부분 문자열](https://leetcode.com/problems/longest-substring-without-repeating-characters/)
중복 문자가 없는 가장 긴 부분 문자열의 길이를 리턴하라.
  - 풀이 1 슬라이딩 윈도우와 투 포인터로 사이즈 조절
  ```python3
  def lengthOfLongestSubstring(s: str) -> int:
    used = {}
    max_length = start = 0
    for index, char in enumerate(s):
      # 이미 등장했던 문자라면 'start' 위치 갱신
      if char in used and start <= used[char]:
        start = used[char] + 1
      else:  # 최대 부분 문자열 길이 갱신
        max_length = max(max_length, index - start + 1)
  
      # 현재 문자의 위치 삽입
      used[char] = index
  
    return max_length
  ```
# [상위 K 빈도 요소](https://leetcode.com/problems/top-k-frequent-elements/)
상위 k번 이상 등장하는 요소를 추출하라.
  - 풀이 1 Counter를 이용한 음수 순 추출
  ```python3
  def topKFrequent(nums: List[int], k: int) -> List[int]:
    freqs = collections.Counter(nums)
    freqs_heap = []
    # 힙에 음수로 삽입
    for f in freqs:
      heapq.heappush(freqs_heap, (-freqs[f], f))
  
    topk = list()
    # k번 만큼 추출, 최소 힙(Min Heap)이므로 가장 작은 음수 순으로 추출
    for _ in range(k):
      topk.append(heapq.heappop(freqs_heap)[1])
  
    return topk

  ```
  - 풀이 2 파이썬다운 방식
  ```python3
  def topKFrequent(nums: List[int], k: int) -> List[int]:
    return list(zip(*collections.Counter(nums).most_common(k)))[0]
  ```
  - zip(): 2개 이상의 시퀀스를 짧은 길이를 기준으로 일대일 대응하는 새로운 튜플 시퀀스를 만드는 역할.       
    제너레이터를 리턴하며 리스트로 감싸면 실젯값이 추출된다.
  - 아스테리스크(*): Unpack. 시퀀스를 풀어헤치는 연산자이다. Unpack이 아닌 Packing도 수행할 수 있다.      
    예시로 zip은 파라미터 개수에 관계없이 수행되는데 이는 내부적으로 *을 사용하여 파라미터를 패킹하여 파라미터 변수 하나로 처리된다.        
     **은 키/값 페어를 언패킹한다.
