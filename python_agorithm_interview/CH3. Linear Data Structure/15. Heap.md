# 힙
힙의 특성(최소 힙(Min Heap)에서는 부모가 항상 작거나 같다)을 만족하는 거의 완전한 트리(Almost Complete Tree)인 특수한 트리 기반의 자료구조다.       
힙은 정렬된 구조가 아님.       
![image](https://github.com/user-attachments/assets/e1095d7c-a7b3-4f52-a5b8-ffd0a3b6c100)
계산을 편하기 위해 인덱스는 1부터 사용한다.
힙 정렬, 최소 신장 트리를 구현하는 프림 알고리즘, 중앙값의 근사값을 빠르게 구하는 데도 활용된다.
## 힙 연산
```python3
class BinaryHeap(object):
  def __init__(self):
    self.items = [None]

  def __len__(self):
    return len(self.items) - 1
```
### 삽입
  - 힙에 요소를 삽입하기 위해 Up-Heap 연산을 수행해야 한다.(percolate_up())
      1. 요소를 가장 하위 레벨의 최대한 왼쪽으로 삽입한다.(배열로 표현할 경우 가장 마지막에 삽입한다)
      2. 부모 값과 비교해 값이 더 작은 경우 위치를 변경한다.
      3. 계속해서 부모 값과 비교해 위치를 변경한다.(가장 작은 값이 경우 루트까지 올라감)
      ![image](https://github.com/user-attachments/assets/a12ab93b-8015-4dd4-be75-8c422b60f5ae)
  ```python3
  def _percolate_up(self):
    i = len(self)
    patent = i // 2
    while parent > 0:
        if self.heap[parent] > self.heap[i]:
            self.heap[parent], self.heap[i] = self.heap[i], self.heap[parent]
            i = parent
            parent = i // 2

  def insert(self, k):
      self.heap.append(k)
      self._percolate_up()
  ```
### 추출
추출 후 비어 있는 루트에 가장 마지막 요소가 올라가고 자식 노드와 값을 비교해서 크다면 내려가는 Down-Heap 연산이 수행된다.
![image](https://github.com/user-attachments/assets/3d1f2eff-ebaf-40ba-a271-9ed124ae6227)        
O(logn)이다.
  ```python3
  def _percolate_down(self, idx):
      left = idx * 2
      right = idx * 2 + 1
      smallest = idx
  
      if left < len(self) and self.heap[left] < self.heap[smallest]:
          smallest = left
  
      if right < len(self) and self.heap[right] < self.heap[smallest]:
          smallest = right
  
      if smallest != idx:
          self.heap[idx], self.heap[smallest] = self.heap[smallest], self.heap[idx]
          self._percolate_down(smallest)
  
  def extract(self):
      extracted = self.heap[1]
      self.heap[1] = self.heap[-1]
      self.items.pop()
      self._percolate_down(1)
      return extracted
  ```

이진 힙은 상/하 관계를 보장하며, 이진 탐색 트리(BST)는 좌우 관계를 보장한다.
따라서 BST는 탐색과 갑입 모두 O(logn)에 가능하며, 모든 값이 정렬되어야 할 때 사용하고 
이진 힙은 가장 작거나 큰 값을 조회할 때 사용한다.(O(1)에 가능)

# [배열의 K번째 큰 요소](https://leetcode.com/problems/kth-largest-element-in-an-array/)
정렬되지 않은 배열에서 k번재 큰 요소를 추출하라.
  - 풀이 1 heapq 모듈 이용
    ```python3
    def findKthLargest(self, nums: List[int], k: int) -> int:
      heap = list()
      for n in nums:
          heapq.heappush(heap, -n)
  
      for _ in range(k):
          heapq.heappop(heap)
  
      return -heapq.heappop(heap)
    ```
  - 풀이 2 heapq 모듈의 heapify 이용
    ```python3
    def findKthLargest(self, nums: List[int], k: int) -> int:
        heapq.heapify(nums)
    
        for _ in range(len(nums) - k):
            heapq.heappop(nums)
    
        return heapq.heappop(nums)
    ```
  - 풀이 3 heapq 모듈의 nlargest 이용
    ```python3
    def findKthLargest(self, nums: List[int], k: int) -> int:
        return heapq.nlargest(k, nums)[-1]
    ```
  - 풀이 4 정렬을 이용한 풀이
    ```python3
    def findKthLargest(self, nums: List[int], k: int) -> int:
        return sorted(nums, reverse=True)[k - 1]
    ```


    




