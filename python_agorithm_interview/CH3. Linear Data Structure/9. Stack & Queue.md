# 스택
  - LIFO(후입선출)
  - push와 pop과 같은 2가지 주요 연산을 지원하는 요소의 컬렉션으로 사용되는 추상 자료형이다.
    - push(): 요소를 컬렉션에 추가한다.
    - pop(): 요소를 컬렉션에 추가한다.
  - 리스트가 스택의 모든 연산을 지원함
  - 컴파일러가 출력하는 에러도 스택처럼 맨 마지막 에러가 가장 먼저 출력되는 순서를 보인다.
  - 연결 리스트를 이용한 스택 ADT 구현
    ```python3
    class Node:
      def __init__(self, item, next):
        self.item = item
        self.next = next
    class Stack
      def __init__(self):
        self.last = None # 포인터

      def push(self, item):
        self.last = Node(item, self.last) # item이라는 노드가 현재 노드가 되고 이전 가장 마지막 값을 가리킴, 현재 포인터는 새로 추가된 노드

      def pop(self):
        item = self.last.item
        self.last = self.last.next
        retrun item
    ```
# [유효한 괄호](https://leetcode.com/problems/valid-parentheses/)
괄호로 된 입력값이 올바른지 판별하라
  - 풀이 1 스택 일치 여부 판별
  - (, {, [ 는 푸쉬, ), }, ] 는 팝한 결과가 매핑 테이블 결과와 매칭되는지 확인
  ```python3
  def isValid(self, s: str) -> bool:
    stack = []
    table = {
      ')': '(',
      '}': '{',
      ']': '['
    }
    # 스택 이용 예외 처리 및 일치 여부 판별
    for char in s:
      if char nont in table:
        stack.append(char)
      elif not stack or table[char] != stack.pop():
        return False
    return len(stack) == 0
  ```
# [중복 문자 제거](https://leetcode.com/problems/remove-duplicate-letters/)
중복된 문자를 제외하고 사전식 순서로 나열하라
  - 풀이 1 재귀를 이용한 분리
    - 중복 문자를 제외한 알파벳 순으로 문자열 입력값을 모두 정렬한 다음 차례대로 빠른 순서대로 suffix를 분리하여 확인
    - 전체 집합과 접미사 집합이 일차하면 분리 가능
    - 분리 가능할 경우 이후의 동일한 알파벳은 제거
  ```python3
  def removeDuplicateLetters(self, s: str) -> str:
    # 집합으로 정렬
    for char in sorted(s):
      suffix = s[s.index(char):]
      # 전체 집합과 접미사 집합이 일치할 때 분히 진행
      if set(s) == set(suffix):
        return char + self.removeDuplicateLetters(suffix.replace(char, ''))
    return ''
  ```
- 풀이 2 스택을 이용한 문자 제거
  - 문자별 개수를 자동으로 카운팅하는 collections.Counter() 이용
  - 현재 문자가 이전 문자보다 앞선 문자이고 뒤에 카운터가 0 이상이라면 앞선 문자들을 꺼내서 없앤다.
    ```python3
  def removeDuplicateLetters(self, s: str) -> str:
    counter, seen, stack = collections.Counter(s), set(), []

    for char in s:
      counter[char] -= 1
      if char in seen:
        continue
      # 뒤에 붙일 문자가 남아 있다면 스택에서 제거
      while stack and char < stack[-1] and counter[stack[-1] > 0:
        seen.remove((stack.pop())
      stack.append(char)
      seen.add(char)
    return ''.join(stack)
  ```
# [일일 온도](https://leetcode.com/problems/daily-temperatures/)
매일의 화씨 온도 리스트 T를 입력받아서 더 따뜻한 날씨를 위해서는 며칠을 더 기다려야 하는지를 출력하라
  - 풀이 1 스택 값 비교
    - 현재의 인덱스를 쌓아두다가 이전보다 상승하는 지점에서 현재 온도와 스택에 쌓아둔 인덱스 지점의 온도 차이를 비교해서 높다면 스택의 값을 팝으로 꺼내고 현재 인덱스와 스택에 쌓아둔 인덱스의 차이를 정답으로 처리
  ```python3
  def dailyTemperatures(self, T: List[int]) -> List[int]:
    answer = [0] * len(t)
    stack = []
    for i, cur in enumerate(T):
      # 현재 온도가 스택 값보다 높다면 정답 처리
      while stack and cur > T[stack[-1]]:
        last = stack.pop()
        answer[last] = i - last
      stack.append(i)

    return  answer
```

# 큐
  - FIFO(선입선출)
  - 시퀀스의 한쪽 끝에는 엔티티를 추가하고, 다른 반대쪽 끝에는 제거할 수 있는 엔티티 컬렉션이다.
  - 데크를 사용하여 효율적 연산이 가능하다.
# [큐를 이용한 스택 구현]((https://leetcode.com/problems/implement-stack-using-queues/)
큐를 이용해 다음 연산을 지원하는 스택을 구현하라
push(x): x를 스택에 삽입
pop(): 스택의 첫 번째 요소를 삭제
top(): 스택의 첫 번째 요소를 가져온다.
empty(): 스택이 비어 있는지 여부를 리턴한다.
  - 풀이 1 push()할 때 큐를 이용해 재정렬
    ```python3
    class MyStack:
      def __init__(self):
        self.q = collections.deque()

      def push()self, x):
        self.q.append(x)
        # 요소 삽입 후 맨 앞에 두는 상태로 재정렬
        for _ in range(len(slef.q) - 1):
          self.q.append(self.q.popleft())

      def pop(self):
        return self.q.popleft()

      def top(self):
        return self.q[0]

      def empty(self):
        return len(self.q) == 0
    ```
# [스택을 이용한 큐 구현[(https://leetcode.com/problems/implement-queue-using-stacks/)
스택을 이용해 다음 연산을 지원하는 큐를 구현하라
push(x): x를 큐 마지막에 삽입
pop(): 큐의 첫 번째 요소를 삭제
peek(): 큐의 첫 번째 요소를 가져온다.
empty(): 큐가 비어 있는지 여부를 리턴한다.
  - 풀이 2 스택 2개 사용
    - 맨 앞의 아이템을 끄집어내야하는데 맨 뒤의 아이템을 끄집어낼 수 밖에 없어 스택이 2개가 필요하다.
    ```python3
    class MyStack:
      def __init__(self):
        self.input = []
        self.output = []

      def push()self, x):
        self.input.append(x)

      def pop(self):
        self.peek()
        return self.output.pop()

      def peek(self):
        # output이 없으면 모두 재입력
        if not self.output:
          while self.input:
            self.output.append(self.input.pop())
        return self.output[-1]

      def empty(self):
        return self.input == [] and self.ouput = []
    ```
# [원형 큐 디자인](https://leetcode.com/problems/design-circular-queue/)
원형 큐를 디자인하라.
  - 풀이 1 배열을 이용한 풀이
    - 원형 큐는 마지막 위치가 시작 위치와 연결되는 원형 구조를 듸는 큐이다.
    - 처음 위치와 마지막 위치를 연결하는 원형 구조를 만들고 두 위치를 가리키는 두 포인터와 비슷함
    - 전체 길이만큼 나머지 연산을 하여 포인터의 위치가 전체 길이를 벗어나지 않게 한다.
    - rear의 위치가 None이 아니라면 비정상적인 경우이므로 False 리턴
  ```python3
  class MyCircularQueue:
    def __init__(self, k: int):
      self.q = [None] * k
      self.maxlen = k
      self.p1 = 0
      self.p2 = 0

  #enQueue(): rear 포인터 이동
  def enQueue(self, value: int):
    if self.q[self.p2] is None:
      self.q[self.p2] = value
      self.p2 = (slef.p2 + 1) % self.maxlen
      return True
    else:
      return False

  # deQueue(): front 포인터 이동
  def deQueue(self) -> bool:
    if self.q[self.p1] is None:
      return False
    else:
      self.q[self.p1] = None
      self.p1 = (self.p1 + 1) % self.maxlen
      return True

  def Front(self) -> int:
    return -1 if self.q[self.p1] is None else self.q[slef.p1]

  def Rear(self) -> int:
    return -1 if self.q[self.p2] is None else self.q[self.p2 - 1]

  def isEmpty(self) -> bool:
    return self.p1 == self.p2 and self.q[self.p1] is None

  def isFull(self) -> bool:
    retrun self.p1 == self.p2 and self.q[self.p1] is not None
```
