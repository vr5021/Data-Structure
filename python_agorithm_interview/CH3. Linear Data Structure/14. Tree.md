# Tree
íŠ¸ë¦¬ëŠ” ê³„ì¸µí˜• íŠ¸ë¦¬ êµ¬ì¡°ë¥¼ ì‹œë®¬ë ˆì´ì…˜ í•˜ëŠ” ì¶”ìƒ ìë£Œí˜•ìœ¼ë¡œ ë£¨íŠ¸ ê°’ê³¼ ë¶€ëª¨-ìì‹ ê´€ê³„ì˜ ì„œë¸ŒíŠ¸ë¦¬ë¡œ êµ¬ì„±ë˜ë©°, ì„œë¡œ ì—°ê²°ëœ ë…¸ë“œì˜ ì§‘í•©ì´ë‹¤.
ì¬ê·€ë¡œ ì •ì˜ëœ ìì‹œ ì°¸ì¡° ìë£Œêµ¬ì¡°ë¡œ ì—¬ëŸ¬ ê°œì˜ íŠ¸ë¦¬(ì„œë¸Œ íŠ¸ë¦¬)ê°€ ìŒ“ì•„ ì˜¬ë ¤ì ¸ í° íŠ¸ë¦¬ê°€ ëœë‹¤.
# íŠ¸ë¦¬ì˜ ê° ëª…ì¹­
![image](https://github.com/user-attachments/assets/2196e916-b7f7-4c86-8fd6-84d13200a5ee)            
  - ì°¨ìˆ˜(Degree): ìì‹ ë…¸ë“œì˜ ê°œìˆ˜           
  - í¬ê¸°(Size): ìì‹ ì„ í¬í•¨í•œ ëª¨ë“  ìì‹ ë…¸ë“œì˜ ê°œìˆ˜         
  - ë†’ì´(height): í˜„ì¬ ìœ„ì¹˜ì—ì„œë¶€í„° Leafê¹Œì§€ì˜ ê±°ë¦¬           
  - ê¹Šì´(Depth): ë£¨íŠ¸ì—ì„œë¶€í„° í˜„ì¬ ë…¸ë“œê¹Œì§€ì˜ ê±°ë¦¬          
  - ë ˆë²¨ì€ 0ì—ì„œë¶€í„° ì‹œì‘         
# ê·¸ë˜í”„ vs íŠ¸ë¦¬
  - íŠ¸ë¦¬ëŠ” ìˆœí™˜ êµ¬ì¡°ë¥¼ ê°–ì§€ ì•ŠëŠ” ê·¸ë˜í”„ì´ë‹¤.         
  - ë‹¨ë°©í–¥ ì—°ê²°ë¡œë§Œ ì´ë£¨ì–´ì ¸ ìˆê³  ë£¨íŠ¸, ë¶€ëª¨ ë…¸ë“œëŠ” í•˜ë‚˜ì—¬ì•¼ í•œë‹¤.      
# ì´ì§„ íŠ¸ë¦¬
  - ëª¨ë“  ë…¸ë“œì˜ ì°¨ìˆ˜ê°€ 2 ì´í•˜ì¸ íŠ¸ë¦¬         
  - Full binary Tree: ëª¨ë“  ë…¸ë“œê°€ 0 or 2ê°œì˜ ìì‹ ë…¸ë“œë¥¼ ê°–ëŠ”ë‹¤.           
  - Complete Binary Tree: ë§ˆì§€ë§‰ ë ˆë²¨ì„ ì œì™¸í•˜ê³  ëª¨ë“  ë ˆë²¨ì´ ì™„ì „íˆ ì±„ì›Œì ¸ ìˆìœ¼ë©´ ë§ˆì§€ë§‰ ë ˆë²¨ì˜ ëª¨ë“  ë…¸ë“œëŠ” ê°€ì¥ ì™¼ìª½ë¶€í„° ì±„ì›Œì ¸ ìˆë‹¤.        
  - Perfect Binary Tree: ëª¨ë“  ë…¸ë“œê°€ 2ê°œì˜ ìì‹ ëª¨ë“œë¥¼ ê°–ê³  ìˆìœ¼ë©°, ëª¨ë“  ë¦¬í”„ ë…¸ë“œê°€ ë™ì¼í•œ ê¹Šì´ ë˜ëŠ” ë ˆë²¨ì„ ê°–ëŠ”ë‹¤.          
# [ì´ì§„ íŠ¸ë¦¬ì˜ ìµœëŒ€ ê¹Šì´](https://leetcode.com/problems/maximum-depth-of-binary-tree/)
 ğŸ’¬ ì´ì§„ íŠ¸ë¦¬ì˜ ìµœëŒ€ ê¹Šì´ë¥¼ êµ¬í•˜ë¼.
  - í’€ì´ 1 ë°˜ë³µ êµ¬ì¡°ë¡œ BFS í’€ì´
    - BFSë¡œ í’€ì´í•˜ë¯€ë¡œ í ì„ ì–¸
      ```python3
      def maxDepth(self, root: TreeNode) -> int:
      if root is None:
        return 0
      queue = collections.deque([(root])
      depth = 0
      
      while queue:
        depth += 1
        # í ì—°ì‚° ì¶”ì¶œ ë…¸ë“œì˜ ìì‹ ë…¸ë“œ ì‚½ì…
        for _ in range(len(queue)): # ë¶€ëª¨ ë…¸ë“œì˜ ê¸¸ì´ ë§Œí¼ë§Œ ë°˜ë³µí•˜ë¯€ë¡œ for êµ¬ë¬¸ ì´í›„ì—ëŠ” ë¶€ëª¨ ë…¸ë“œëŠ” ëª¨ë‘ ì¶”ì¶œë˜ê³  ë°”ë„ ë‹¤ìŒì˜ ìì‹ ë…¸ë“œë“¤ë§Œ íì— ì¡´ì¬
          cur_root = queue.popleft()
          if cur_root.left:
            queue.append(cur_root.left)
          if cur_root.right:
            queue.append(cur_root.right)
      # BFS ë°˜ë³µ íšŸìˆ˜ == ê¹Šì´
      return depth
    ```
# [ì´ì§„ íŠ¸ë¦¬ì˜ ì§ê²½](https://leetcode.com/problems/diameter-of-binary-tree/)
ğŸ’¬ ì´ì§„ íŠ¸ë¦¬ì—ì„œ ë‘ ë…¸ë“œ ê°„ ê°€ì¥ ê¸´ ê²½ë¡œì˜ ê¸¸ì´ë¥¼ ì¶œë ¥í•˜ë¼.
  - í’€ì´ 1 ìƒíƒœê°’ ëˆ„ì  íŠ¸ë¦¬ DFS
    - dfsëŠ” í˜„ì¬ ë…¸ë“œ ê¸°ì¤€ ì™¼ìª½, ì˜¤ë¥¸ìª½ ì„œë¸Œ íŠ¸ë¦¬ ì¤‘ ë” ê¹Šì€ ê¹Šì´ +1 ë°˜í™˜
    - í˜„ì¬ ë…¸ë“œì—ì„œ ì™¼ìª½ê³¼ ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬ë¥¼ ì—°ê²°í•˜ëŠ” 2ê°œì˜ ê°„ì„ ì´ë¯€ë¡œ left + right + 2ì™€ slef.longest ì‚¬ì´ì—ì„œ ìµœëŒ“ê°’ì„ ì„ íƒí•œë‹¤.
    ```python3
    class Solution:
      longest: int = 0
    
      def diameterOfBinaryTree(self, root: TreeNode) -> int:
        def dfs(node: TreeNode) -> int:
          if not node:
            return -1
          # ì™¼ìª½, ì˜¤ë¥¸ìª½ì˜ ê° ë¦¬í”„ ë…¸ë“œê¹Œì§€ íƒìƒ‰
          left = dfs(node.left) # ì™¼ìª½ ì„œë¸ŒíŠ¸ë¦¬ì—ì„œ ê°€ì¥ ê¹Šì€ ë¦¬í”„ ë…¸ë“œê¹Œì§€ ê°€ëŠ¥ ê²½ë¡œ ê¸¸ì´
          right = dfs(node.right) # ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬ì—ì„œ ê°€ì¥ ê¹Šì€ ë¦¬í”„ ë…¸ë“œê¹Œì§€ ê°€ëŠ¥ ê²½ë¡œ ê¸¸ì´
          # ê°€ì¥ ê¸´ ê²½ë¡œ
          self.longest = max(self.longest, left + right + 2)
          # ìƒíƒœê°’
          return max(left, right) + 1
        dfs(root)
        return self.longest
    ```
    - ì¤‘ì²© í•¨ìˆ˜ì—ì„œ ë¶€ëª¨ í•¨ìˆ˜ì˜ ë³€ìˆ˜ë¥¼ ì¬í• ë‹¹í•˜ê²Œ ë˜ë©´ ì°¸ì¡° IDê°€ ë³€ê²½ë˜ë©° ë³„ë„ì˜ ë¡œì»¬ ë³€ìˆ˜ë¡œ ì„ ì–¸ë˜ì–´ í•¨ìˆ˜ ë°”ê¹¥ì—ì„œ í´ë˜ìŠ¤ ë³€ìˆ˜ë¡œ ì„ ì–¸ í›„ ì‚¬ìš©í•¨
    - ê°€ë³€ê°ì²´(ë¦¬ìŠ¤íŠ¸, ë”•ì…”ë„ˆë¦¬)ì¼ ê²½ìš° ì¬í• ë‹¹ ì—†ì´ ì¡°ì‘ì´ ê°€ëŠ¥í•˜ë¯€ë¡œ ì¤‘ì²© í•¨ìˆ˜ ë‚´ì—ì„œë„ ë³€ìˆ˜ì˜ ê°’ì„ ì¡°ì‘í•  ìˆ˜ ìˆë‹¤.
# [ê°€ì¥ ê¸´ ë™ì¼ ê°’ì˜ ê²½ë¡œ](https://leetcode.com/problems/longest-univalue-path/)
ğŸ’¬ ë™ì¼í•œ ê°’ì„ ì§€ë‹Œ ê°€ì¥ ê¸´ ê²½ë¡œë¥¼ ì°¾ì•„ë¼.
  - í’€ì´ ìƒíƒœê°’ ê±°ë¦¬ ê³„ì‚° DFS
    - 
    ```python3
    class solution:
      result: int = 0
    
      def longestUnivaluePath(self, root: TreeNode) -> int:
        def dfs(node: TreeNode):
          if not node:
            return 0
    
          # ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ë…¸ë“œê¹Œì§€ DFS ì¬ê·€ íƒìƒ‰
          left = dfs(node.left)
          right = dfs(node.right)
    
          # í˜„ì¬ ë…¸ë“œê°€ ìì‹ ë…¸ë“œì™€ ë™ì¼í•œ ê²½ìš° ê±°ë¦¬ 1 ì¦ê°€
          if node.left and node.left.val == node.val:
            left += 1  
          else:
            left = 0
          if node.right and node.right.val == node.val:
            right += 1
          else:
            right = 0
    
    
          # ì™¼ìª½ê³¼ ì˜¤ë¥¸ìª½ ìì‹ ë…¸ë“œ ê°„ ê±°ë¦¬ì˜ í•© ìµœëŒ“ê°’ì´ ê²°ê³¼
          self.result = max(self.result, left + right)  
          # ìì‹ ë…¸ë“œ ìƒíƒœê°’ ì¤‘ í° ê°’ ë¦¬í„´
          return max(left, right)  
    
        dfs(root)
        return self.result
    ```
# [ì´ì§„ íŠ¸ë¦¬ ë°˜ì „](https://leetcode.com/problems/invert-binary-tree/)
ğŸ’¬ ë£¨íŠ¸ ë…¸ë“œë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì´ì§„ íŠ¸ë¦¬ë¥¼ ë°˜ì „ì‹œí‚¤ëŠ” ë¬¸ì œ
  - í’€ì´ 1 íŒŒì´ì¬ë‹¤ìš´ ë°©ì‹
    ``python3
    def inverTree(self, root: TreeNode) -> TreeNode:
      if root:
          root.left, root.right = self.invertTree(root.right), self.invertTree(root.left)
          return root
      return None
    ``
  - í’€ì´ 2 ë°˜ë³µ êµ¬ì¡°ë¡œ BFS
    ```python3
    def inverTree(self, root: TreeNode) -> TreeNode:
      queue = collections.deque([root])
  
      while queue:
          node = queue.popleft()
          if node:
              node.left, node.right = node.right, node.left
              queue.append(node.left)
              queue.append(node.right)
      return root
  - í’€ì´ 3 ë°˜ë³µ êµ¬ì¡°ë¡œ DFS
    ```python3
    def invertTree(self, root: TreeNode) -> TreeNode:
      stack = collections.deque([root])
      while stack:
          node = stack.pop()
          # ë¶€ëª¨ ë…¸ë“œ ë¶€í„° í•˜í–¥ì‹ ìŠ¤ì™‘
          if node:
            node.left, node.right = node.right, node.left
    
            stack.append(node.left)
            stack.append(node.right)
  
      return root
    ```
  - í’€ì´ 4 ë°˜ë³µ êµ¬ì¡°ë¡œ DFS í›„ìœ„ ìˆœíšŒ
    ```python3
    def invertTree(self, root: TreeNode) -> TreeNode:
      stack = collections.deque([root])
      while stack:
          node = stack.pop()
  
          if node:
              stack.append(node.left)
              stack.append(node.right)
  
              node.left, node.right = node.right, node.left # í›„ìœ„ ìˆœíšŒ
  
      return root
    ```
# [ë‘ ì´ì§„ íŠ¸ë¦¬ ë³‘í•©](https://leetcode.com/problems/merge-two-binary-trees/)
ğŸ’¬ ë‘ ì´ì§„ íŠ¸ë¦¬ë¥¼ ë³‘í•©í•˜ë¼. ì¤‘ë³µë˜ëŠ” ë…¸ë“œëŠ” ê°’ì„ í•©ì‚°í•œë‹¤.
  - í’€ì´ 1 ì¬ê·€ íƒìƒ‰
    ```python3
    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:
      if t1 and t2:
          node = TreeNode(t1.val + t2.val)
          node.left = self.mergeTrees(t1.left, t2.left)
          node.right = self.mergeTrees(t1.right, t2.right)
          return node
      else:
          return t1 or t2
    ```
# [ì´ì§„ íŠ¸ë¦¬ ì§ë ¬í™”](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/)
ğŸ’¬ ì´ì§„ íŠ¸ë¦¬ë¥¼ ë°°ì—´ë¡œ ì§ë ¬í™”í•˜ê³ , ë°˜ëŒ€ë¡œ ì—­ì§ë ¬í™”í•˜ëŠ” ê¸°ëŠ¥ì„ êµ¬í˜„í•˜ë¼.      
ex. [1,2,3,null,null,4,5]
![image](https://github.com/user-attachments/assets/807f085b-9b70-47eb-9a6a-206645d17a98)      
  - í’€ì´ 1 ì§ë ¬í™” & ì—­ì§ë ¬í™” êµ¬í˜„
    - ê°ì²´ì˜ ê³„ì¸µ êµ¬ì¡°ë¥¼ ë°”ì´íŠ¸ ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ë³€ê²½í•˜ëŠ” ì‘ì—…ì„ Pickling ì´ë¼í•œë‹¤.(íŒŒì´ì¬ì˜ ê¸°ë³¸ ì§ë ¬í™” ëª¨ë“ˆì´ pickle ì´ê¸° ë•Œë¬¸)
    - ì²«ë²ˆì§¸ ì¸ë±ìŠ¤ë¥¼ ë¹„ì›Œë†“ê³  1ë¶€í„° ì‹œì‘í•˜ì—¬ ë¶€ëª¨ ë…¸ë“œ i, ìì‹ ë…¸ë“œ 2i, 2i+1ë¡œ êµ¬ì„±ëœë‹¤. ë”°ë¼ì„œ BFSê°€ ì ì ˆí•˜ë‹¤.
      ```python3
      class Codec:
        # ì§ë ¬í™”
        def serialize(self, root: TreeNode) -> str:
            queue = collections.deque([root])
            result = ['#']
            # íŠ¸ë¦¬ BFS ì§ë ¬í™”
            while queue:
                node = queue.popleft()
                if node:
                    queue.append(node.left)
    
                    queue.append(node.right)
                    result.append(str(node.val))
                else:
                    result.append('#')
            return ' '.join(result)
        # ì—­ì§ë ¬í™”
        def deserialize(self, data: str) -> TreeNode:
            if data == '# #':
                return None
    
            nodes = data.split()
            
            root = TreeNode(int(nodes[1]))
            queue = collections.deque([root])
            index = 2
            # ë¹ ë¥¸ ëŸ°ë„ˆì²˜ëŸ¼ ìì‹ ë…¸ë“œ ê²°ê³¼ë¥¼ ë¨¼ì € í™•ì¸í•˜ê³  íì— ì‚½ì…
            while queue:
                node = queue.popleft()
                if nodes[index] is not '#':
                    node.left = TreeNode(int(nodes[index]))
                    queue.append(node.left)
                index += 1
    
                if nodes[index] is not '#':
                    node.right = TreeNode(int(nodes[index]))
                    queue.append(node.right)
                index += 1
            return root
      ```

# [ê· í˜• ì´ì§„ íŠ¸ë¦¬](https://leetcode.com/problems/balanced-binary-tree/)
ğŸ’¬ ì´ì§„ íŠ¸ë¦¬ê°€ ë†’ì´ ê· í˜•(ëª¨ë“  ì„œë¸Œ íŠ¸ë¦¬ ê°„ì˜ ë†’ì´ ì°¨ì´ê°€ 1 ì´í•˜ì¸ ê²ƒ)ì¸ì§€ íŒë‹¨í•˜ë¼.
  - í’€ì´ 1 ì¬ê·€ êµ¬ì¡°ë¡œ ë†’ì´ ì°¨ì´ ê³„ì‚°
    ```python3
    def isBalanced(self, root: TreeNode) -> bool:
      def check(root):
          if not root:
              return 0
              
          left = check(root.left)
          right = check(root.right)
          # ë†’ì´ ì°¨ì´ê°€ ë‚˜ëŠ” ê²½ìš° -1, ì´ì™¸ì—ëŠ” ë†’ì´ì— ë”°ë¼ 1 ì¦ê°€
          if left == -1 or right == -1 or abs(left - right) > 1:
              return -1
          return max(left, right) + 1
      return check(root) != -1
    ```

# [ìµœì†Œ ë†’ì´ íŠ¸ë¦¬](https://leetcode.com/problems/minimum-height-trees/)
ğŸ’¬ ë…¸ë“œ ê°œìˆ˜ì™€ ë¬´ë°©í–¥ ê·¸ë˜í”„ë¥¼ ì…ë ¥ë°›ì•„ íŠ¸ë¦¬ê°€ ìµœì†Œ ë†’ì´ê°€ ë˜ëŠ” ë£¨íŠ¸ì˜ ëª©ë¡ì„ ë¦¬í„´í•˜ë¼.
  - í’€ì´ 1 ë‹¨ê³„ë³„ ë¦¬í”„ ë…¸ë“œ ì œê±°
    ```python3
    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:
      if n <= 1:
          return [0]
      # ì–‘ë°©í–¥ ê·¸ë˜í”„ êµ¬ì„±
      graph = collections.defaultdict(list)
      for i, j in edges:
          graph[i].append(j)
          graph[j].append(i)
  
      # ì²« ë²ˆì§¸ ë¦¬í”„ ë…¸ë“œ ì¶”ê°€
      leaves = []
      for i in range(n + 1):
          if len(graph[i]) == 1:
              leaves.append(i)
  
      # ë£¨íŠ¸ ë…¸ë“œë§Œ ë‚¨ì„ ë•Œê¹Œì§€ ë°˜ë³µ ì œê±°
      while n > 2:
          n -= len(leaves)
          new_leaves = []
          for leaf in leaves:
              neighbor = graph[leaf].pop()
              graph[neighbor].remove(leaf)
  
              if len(graph[neighbor]) == 1:
                  new_leaves.append(neighbor)
          leaves = new_leaves
      return leaves
    ```
# ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬(BSF)
  - ì •ë ¬ëœ íŠ¸ë¦¬. ì™¼ìª½ ì„œë¸ŒíŠ¸ë¦¬ì—ëŠ” í˜„ì¬ ë…¸ë“œë³´ë‹¤ ì‘ì€ ê°’ì´, ì˜¤ë¥¸ìª½ ì„œë¸ŒíŠ¸ë¦¬ì—ëŠ” í˜„ì¬ ë…¸ë“œë³´ë‹¤ í¬ê±°ë‚˜ ê°™ì€ ê°’ì„ ì§€ë‹Œ ë…¸ë“œë“¤ë¡œ ì´ë£¨ì–´ì ¸ ìˆëŠ” íŠ¸ë¦¬ì´ë‹¤.     
  - ë”°ë¼ì„œ íƒìƒ‰ ì‹œ ì‹œê°„ ë³µì¡ë„ê°€ O(logn)ì´ë‹¤. ë‹¤ë§Œ ê· í˜•ì´ ê¹¨ì§„ íŠ¸ë¦¬ì˜ ê²½ìš° íƒìƒ‰ ì‹œ O(n)ì— ê·¼ì ‘í•œ ì‹œê°„ì´ ì†Œìš”ë  ìˆ˜ ìˆìœ¼ë¯€ë¡œ íŠ¸ë¦¬ì˜ ê· í˜•ì„ ë§ì¶”ëŠ” ê²ƒì´ ì¤‘ìš”í•´ì§„ë‹¤.
# ìê°€ ê· í˜• ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬
  - ì‚½ì…, ì‚­ì œ ì‹œ ìë™ìœ¼ë¡œ ë†’ì´ë¥¼ ì‘ê²Œ ìœ ì§€í•˜ëŠ” ë…¸ë“œ ê¸°ë°˜ì˜ ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ë‹¤.
  - ëŒ€í‘œì ì¸ í˜•íƒœë¡œ AVL íŠ¸ë¦¬ì™€ Red-Black íŠ¸ë¦¬ ë“±ì´ ìˆë‹¤.
# [ì •ë ¬ëœ ë°°ì—´ì˜ ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ ë³€í™˜](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)
ğŸ’¬ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬ëœ ë°°ì—´ì„ ë†’ì´ ê· í˜• ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ë¡œ ë³€í™˜í•˜ë¼.
  - í’€ì´ 1 ì´ì§„ ê²€ìƒ‰ ê²°ê³¼ë¡œ íŠ¸ë¦¬ êµ¬ì„±
    ```python3
    def SortedArrayToBST(self, nums: List[int]) -> TreeNode:
      if not nums:
          return None
      mid = len(nums) // 2
  
      # ë¶„í•  ì •ë³µìœ¼ë¡œ ì´ì§„ ê²€ìƒ‰ ê²°ê³¼ íŠ¸ë¦¬ êµ¬ì„±
      node = TreeNode(nums[mid])
      node.left = self.SortedArrayToBST(nums[:mid])
      node.right = self.SortedArrayToBST(nums[mid + 1:])
      
      return node
    ```
# [ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬(BST)ë¥¼ ë” í° ìˆ˜ í•©ê³„ íŠ¸ë¦¬ë¡œ](https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/)
ğŸ’¬ BSTì˜ ê° ë…¸ë“œë¥¼ í˜„ì¬ê°’ë³´ë‹¤ ë” í° ê°’ì„ ê°€ì§„ ëª¨ë“  ë…¸ë“œì˜ í•©ìœ¼ë¡œ ë§Œë“¤ì–´ë¼.
  - í’€ì´ 1 ì¤‘ìœ„ ìˆœíšŒë¡œ ë…¸ë“œ ê°’ ëˆ„ì 
    ```python3
    class Solution:
      val: int = 0
  
      def bstToGst(self, root: TreeNode) -> TreeNode:
          # ì¤‘ìœ„ ìˆœíšŒ ë…¸ë“œ ê°’ ëˆ„ì 
          if root:
              self.bstToGst(root.right)
              self.val += root.val
              root.val = self.val
              self.bstToGst(root.left)
              
          return root
    ```
# [ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬(BST) í•©ì˜ ë²”ìœ„](https://leetcode.com/problems/range-sum-of-bst/)
  - í’€ì´ 1 ì¬ê·€ êµ¬ì¡° DFSë¡œ ë¸Œë£¨íŠ¸ í¬ìŠ¤ íƒìƒ‰
    ```python3
    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:
      if not root:
          return 0
  
      if root.val < L:
          return self.rangeSumBST(root.right, L, R)
      elif root.val > R:
          return self.rangeSumBST(root.left, L, R)
      return root.val + self.rangeSumBST(root.left, L, R) + self.rangeSumBST(root.right, L, R)
    ```
  - í’€ì´ 2 DFS ê°€ì§€ì¹˜ê¸°ë¡œ í•„ìš”í•œ ë…¸ë“œ íƒìƒ‰
    ```python3
    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:
      def dfs(node: TreeNode):
          if not node:
              return 0
  
          if node.val < L:
              return dfs(node.right)
          elif node.val > R:
              return dfs(node.left)
          return node.val + dfs(node.left) + dfs(node.right)
      return dfs(root)
    ```
  - í’€ì´ 3 ë°˜ë³µ êµ¬ì¡° DFSë¡œ í•„ìš”í•œ ë…¸ë“œ íƒìƒ‰
    ```python3
    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:
      stack, sum = [root], 0
  
      # ìŠ¤íƒ ì´ìš© í•„ìš”í•œ ë…¸ë“œ DFS ë°˜ë³µ
      while stack:
          node = stack.pop()
          if node:
              if L <= node.val <= R:
                  sum += node.val
              if L < node.val:
                  stack.append(node.left)
              if node.val < R:
                  stack.append(node.right)
      return sum
    ```
  - í’€ì´ 4 ë°˜ë³µ êµ¬ì¡° BFSë¡œ í•„ìš”í•œ ë…¸ë“œ íƒìƒ‰
    ```python3
    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:
      stack, sum = [root], 0
      # í ì—°ì‚°ì„ ì´ìš©í•´ ë°˜ë³µ êµ¬ì¡° BFSë¡œ í•„ìš”í•œ ë…¸ë“œ íƒìƒ‰
      while stack:
          node = stack.pop(0)
          if node:
              if L < node.val:
                  stack.append(node.left)
              if node.val < R:
                  stack.append(node.right)
              if L <= node.val <= R:
                  sum += node.val
      return sum
    ```
# [ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬(BST) ë…¸ë“œ ê°„ ìµœì†Œ ê±°ë¦¬](https://leetcode.com/problems/minimum-distance-between-bst-nodes/)
ğŸ’¬ ë‘ ë…¸ë“œ ê°„ ê°’ì˜ ì°¨ì´ê°€ ê°€ì¥ ì‘ì€ ë…¸ë“œì˜ ê°’ì˜ ì°¨ì´ë¥¼ ì¶œë ¥í•˜ë¼.
  - í’€ì´ 1 ì¬ê·€ êµ¬ì¡°ë¡œ ì¤‘ìœ„ ìˆœíšŒ
    ```python3
    class Solution:
      prev = -sys.maxsize
      result = sys.maxsize
  
      # ì¬ê·€ êµ¬ì¡° ì¤‘ìœ„ ìˆœíšŒ ë¹„êµ ê²°ê³¼
      def minDiffInBST(self, root: TreeNode) -> int:
          if root.left:
              self.minDiffInBST(root.left)
  
          self.result = min(self.result, root.val - self.prev)
          self.prev = root.val
  
          if root.right:
              self.minDiffInBST(root.right)
  
          return self.result
    ```
  - í’€ì´ 2 ë°˜ë³µ êµ¬ì¡°ë¡œ ì¤‘ìœ„ ìˆœíšŒ
    ```python3
    def minDiffInBST(self, root: TreeNode) -> int:
      prev = -sys.maxsize
      result = sys.maxsize
  
      # ì¤‘ìœ„ ìˆœíšŒ
      stack = []
      node = root
  
      # ë°˜ë³µ êµ¬ì¡° ì¤‘ìœ„ ìˆœíšŒ ë¹„êµ ê²°ê³¼
      while stack or node:
          while node:
              stack.append(node)
              node = node.left
          node = stack.pop()
  
          result = min(result, node.val - prev)
          prev = node.val
  
          node = node.right
  
      return result
    ```
# íŠ¸ë¦¬ ìˆœíšŒ
  - ê·¸ë˜í”„ ìˆœíšŒì˜ í•œ í˜•íƒœë¡œ íŠ¸ë¦¬ ìë£Œêµ¬ì¡°ì—ì„œ ê° ë…¸ë“œë¥¼ ì •í™•íˆ í•œ ë²ˆ ë°©ë¬¸í•˜ëŠ” ê³¼ì •
  - L,R,N ìœ¼ë¡œ ì™¼ìª½ ì„œë¸Œ, ì˜¤ë¥¸ìª½ ì„œë¸Œ, ìê¸° ìì‹  ë…¸ë“œë¥¼ ë§í•  ë•Œ ë°©ë¬¸ ìˆœì„œì— ë”°ë¼ 3ê°€ì§€ ë°©ì‹ìœ¼ë¡œ êµ¬ë¶„í•œë‹¤.
    - ì „ìœ„ ìˆœíšŒ(Pre-Order) NLR
    - ì¤‘ìœ„ ìˆœíšŒ(In-Order) LNR
    - í›„ìœ„ ìˆœíšŒ(Post-Order) LRN
![image](https://github.com/user-attachments/assets/0717a17c-0658-4db9-89f0-ecf67e0916be)       

ì˜ ê²½ìš°

```python3
  class Node:
    def __init__(self, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

  root = Node('F',
            Node('B',
                 Node('A'),
                 Node('D',
                      Node('C'), Node('E'))),
            Node('G',
                 None,
                 Node('I', Node('H'))))
## ì „ìœ„ ìˆœíšŒ
```python3
def preorder(node):
    if node is None:
        return
    print(node.val, end=' ')
    preorder(node.left)
    preorder(node.right)
```
## ì¤‘ìœ„ ìˆœíšŒ
```python3
def inorder(node):
    if node is None:
        return
    inorder(node.left)
    print(node.val, end=' ')
    inorder(node.right)
```
## í›„ìœ„ ìˆœíšŒ
```python3
def postorder(node):
    if node is None:
        return
    postorder(node.left)
    postorder(node.right)
    print(node.val, end=' ')
```

# [ì „ìœ„, ì¤‘ìœ„ ìˆœíšŒ ê²°ê³¼ë¡œ ì´ì§„ íŠ¸ë¦¬ êµ¬ì¶•](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)
ğŸ’¬ íŠ¸ë¦¬ì˜ ì „íœ˜, ì¤‘ìœ„ ìˆœíšŒ ê²°ê³¼ë¥¼ ì…ë ¥ê°’ìœ¼ë¡œ ë°›ì•„ ì´ì§„ íŠ¸ë¦¬ë¥¼ êµ¬ì¶•í•˜ë¼.
  - í’€ì´ 1 ì „ìœ„ ìˆœíšŒ ê²°ê³¼ë¡œ ì¤‘ìœ„ ìˆœíšŒ ë¶„í•  ì •ë³µ
    ```python3
    def buildTree(preorder: List[int], inorder: List[int]) -> TreeNode:
      if inorder:
          # ì „ìœ„ ìˆœíšŒ ê²°ê³¼ëŠ” ì¤‘ìœ„ ìˆœíšŒ ë¶„í•  ì¸ë±ìŠ¤
          index = inorder.index(preorder.pop(0))
  
          # ì¤‘ìœ„ ìˆœíšŒ ê²°ê³¼ ë¶„í•  ì •ë³µ
          node = TreeNode(inorder[index])
          node.left = buildTree(preorder, inorder[0:index])
          node.right = buildTree(preorder, inorder[index + 1:])
          
          return node
    ```






