# Tree
트리는 계층형 트리 구조를 시뮬레이션 하는 추상 자료형으로 루트 값과 부모-자식 관계의 서브트리로 구성되며, 서로 연결된 노드의 집합이다.
재귀로 정의된 자시 참조 자료구조로 여러 개의 트리(서브 트리)가 쌓아 올려져 큰 트리가 된다.
# 트리의 각 명칭
![image](https://github.com/user-attachments/assets/2196e916-b7f7-4c86-8fd6-84d13200a5ee)            
  - 차수(Degree): 자식 노드의 개수           
  - 크기(Size): 자신을 포함한 모든 자식 노드의 개수         
  - 높이(height): 현재 위치에서부터 Leaf까지의 거리           
  - 깊이(Depth): 루트에서부터 현재 노드까지의 거리          
  - 레벨은 0에서부터 시작         
# 그래프 vs 트리
  - 트리는 순환 구조를 갖지 않는 그래프이다.         
  - 단방향 연결로만 이루어져 있고 루트, 부모 노드는 하나여야 한다.      
# 이진 트리
  - 모든 노드의 차수가 2 이하인 트리         
  - Full binary Tree: 모든 노드가 0 or 2개의 자식 노드를 갖는다.           
  - Complete Binary Tree: 마지막 레벨을 제외하고 모든 레벨이 완전히 채워져 있으면 마지막 레벨의 모든 노드는 가장 왼쪽부터 채워져 있다.        
  - Perfect Binary Tree: 모든 노드가 2개의 자식 모드를 갖고 있으며, 모든 리프 노드가 동일한 깊이 또는 레벨을 갖는다.          
# [이진 트리의 최대 깊이](https://leetcode.com/problems/maximum-depth-of-binary-tree/)
 💬 이진 트리의 최대 깊이를 구하라.
  - 풀이 1 반복 구조로 BFS 풀이
    - BFS로 풀이하므로 큐 선언
      ```python3
      def maxDepth(self, root: TreeNode) -> int:
      if root is None:
        return 0
      queue = collections.deque([(root])
      depth = 0
      
      while queue:
        depth += 1
        # 큐 연산 추출 노드의 자식 노드 삽입
        for _ in range(len(queue)): # 부모 노드의 길이 만큼만 반복하므로 for 구문 이후에는 부모 노드는 모두 추출되고 바도 다음의 자식 노드들만 큐에 존재
          cur_root = queue.popleft()
          if cur_root.left:
            queue.append(cur_root.left)
          if cur_root.right:
            queue.append(cur_root.right)
      # BFS 반복 횟수 == 깊이
      return depth
    ```
# [이진 트리의 직경](https://leetcode.com/problems/diameter-of-binary-tree/)
💬 이진 트리에서 두 노드 간 가장 긴 경로의 길이를 출력하라.
  - 풀이 1 상태값 누적 트리 DFS
    - dfs는 현재 노드 기준 왼쪽, 오른쪽 서브 트리 중 더 깊은 깊이 +1 반환
    - 현재 노드에서 왼쪽과 오른쪽 서브트리를 연결하는 2개의 간선이므로 left + right + 2와 slef.longest 사이에서 최댓값을 선택한다.
    ```python3
    class Solution:
      longest: int = 0
    
      def diameterOfBinaryTree(self, root: TreeNode) -> int:
        def dfs(node: TreeNode) -> int:
          if not node:
            return -1
          # 왼쪽, 오른쪽의 각 리프 노드까지 탐색
          left = dfs(node.left) # 왼쪽 서브트리에서 가장 깊은 리프 노드까지 가능 경로 길이
          right = dfs(node.right) # 오른쪽 서브트리에서 가장 깊은 리프 노드까지 가능 경로 길이
          # 가장 긴 경로
          self.longest = max(self.longest, left + right + 2)
          # 상태값
          return max(left, right) + 1
        dfs(root)
        return self.longest
    ```
    - 중첩 함수에서 부모 함수의 변수를 재할당하게 되면 참조 ID가 변경되며 별도의 로컬 변수로 선언되어 함수 바깥에서 클래스 변수로 선언 후 사용함
    - 가변객체(리스트, 딕셔너리)일 경우 재할당 없이 조작이 가능하므로 중첩 함수 내에서도 변수의 값을 조작할 수 있다.
# [가장 긴 동일 값의 경로](https://leetcode.com/problems/longest-univalue-path/)
💬 동일한 값을 지닌 가장 긴 경로를 찾아라.
  - 풀이 상태값 거리 계산 DFS
    - 
    ```python3
    class solution:
      result: int = 0
    
      def longestUnivaluePath(self, root: TreeNode) -> int:
        def dfs(node: TreeNode):
          if not node:
            return 0
    
          # 존재하지 않는 노드까지 DFS 재귀 탐색
          left = dfs(node.left)
          right = dfs(node.right)
    
          # 현재 노드가 자식 노드와 동일한 경우 거리 1 증가
          if node.left and node.left.val == node.val:
            left += 1  
          else:
            left = 0
          if node.right and node.right.val == node.val:
            right += 1
          else:
            right = 0
    
    
          # 왼쪽과 오른쪽 자식 노드 간 거리의 합 최댓값이 결과
          self.result = max(self.result, left + right)  
          # 자식 노드 상태값 중 큰 값 리턴
          return max(left, right)  
    
        dfs(root)
        return self.result
    ```
# [이진 트리 반전](https://leetcode.com/problems/invert-binary-tree/)
💬 루트 노드를 기준으로 이진 트리를 반전시키는 문제
  - 풀이 1 파이썬다운 방식
    ``python3
    def inverTree(self, root: TreeNode) -> TreeNode:
      if root:
          root.left, root.right = self.invertTree(root.right), self.invertTree(root.left)
          return root
      return None
    ``
  - 풀이 2 반복 구조로 BFS
    ```python3
    def inverTree(self, root: TreeNode) -> TreeNode:
      queue = collections.deque([root])
  
      while queue:
          node = queue.popleft()
          if node:
              node.left, node.right = node.right, node.left
              queue.append(node.left)
              queue.append(node.right)
      return root
  - 풀이 3 반복 구조로 DFS
    ```python3
    def invertTree(self, root: TreeNode) -> TreeNode:
      stack = collections.deque([root])
      while stack:
          node = stack.pop()
          # 부모 노드 부터 하향식 스왑
          if node:
            node.left, node.right = node.right, node.left
    
            stack.append(node.left)
            stack.append(node.right)
  
      return root
    ```
  - 풀이 4 반복 구조로 DFS 후위 순회
    ```python3
    def invertTree(self, root: TreeNode) -> TreeNode:
      stack = collections.deque([root])
      while stack:
          node = stack.pop()
  
          if node:
              stack.append(node.left)
              stack.append(node.right)
  
              node.left, node.right = node.right, node.left # 후위 순회
  
      return root
    ```
# [두 이진 트리 병합](https://leetcode.com/problems/merge-two-binary-trees/)
💬 두 이진 트리를 병합하라. 중복되는 노드는 값을 합산한다.
  - 풀이 1 재귀 탐색
    ```python3
    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:
      if t1 and t2:
          node = TreeNode(t1.val + t2.val)
          node.left = self.mergeTrees(t1.left, t2.left)
          node.right = self.mergeTrees(t1.right, t2.right)
          return node
      else:
          return t1 or t2
    ```
# [이진 트리 직렬화](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/)
💬 이진 트리를 배열로 직렬화하고, 반대로 역직렬화하는 기능을 구현하라.      
ex. [1,2,3,null,null,4,5]
![image](https://github.com/user-attachments/assets/807f085b-9b70-47eb-9a6a-206645d17a98)      
  - 풀이 1 직렬화 & 역직렬화 구현
    - 객체의 계층 구조를 바이트 스트림으로 변경하는 작업을 Pickling 이라한다.(파이썬의 기본 직렬화 모듈이 pickle 이기 때문)
    - 첫번째 인덱스를 비워놓고 1부터 시작하여 부모 노드 i, 자식 노드 2i, 2i+1로 구성된다. 따라서 BFS가 적절하다.
      ```python3
      class Codec:
        # 직렬화
        def serialize(self, root: TreeNode) -> str:
            queue = collections.deque([root])
            result = ['#']
            # 트리 BFS 직렬화
            while queue:
                node = queue.popleft()
                if node:
                    queue.append(node.left)
    
                    queue.append(node.right)
                    result.append(str(node.val))
                else:
                    result.append('#')
            return ' '.join(result)
        # 역직렬화
        def deserialize(self, data: str) -> TreeNode:
            if data == '# #':
                return None
    
            nodes = data.split()
            
            root = TreeNode(int(nodes[1]))
            queue = collections.deque([root])
            index = 2
            # 빠른 런너처럼 자식 노드 결과를 먼저 확인하고 큐에 삽입
            while queue:
                node = queue.popleft()
                if nodes[index] is not '#':
                    node.left = TreeNode(int(nodes[index]))
                    queue.append(node.left)
                index += 1
    
                if nodes[index] is not '#':
                    node.right = TreeNode(int(nodes[index]))
                    queue.append(node.right)
                index += 1
            return root
      ```

# [균형 이진 트리](https://leetcode.com/problems/balanced-binary-tree/)
💬 이진 트리가 높이 균형(모든 서브 트리 간의 높이 차이가 1 이하인 것)인지 판단하라.
  - 풀이 1 재귀 구조로 높이 차이 계산
    ```python3
    def isBalanced(self, root: TreeNode) -> bool:
      def check(root):
          if not root:
              return 0
              
          left = check(root.left)
          right = check(root.right)
          # 높이 차이가 나는 경우 -1, 이외에는 높이에 따라 1 증가
          if left == -1 or right == -1 or abs(left - right) > 1:
              return -1
          return max(left, right) + 1
      return check(root) != -1
    ```

# [최소 높이 트리](https://leetcode.com/problems/minimum-height-trees/)
💬 노드 개수와 무방향 그래프를 입력받아 트리가 최소 높이가 되는 루트의 목록을 리턴하라.
  - 풀이 1 단계별 리프 노드 제거
    ```python3
    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:
      if n <= 1:
          return [0]
      # 양방향 그래프 구성
      graph = collections.defaultdict(list)
      for i, j in edges:
          graph[i].append(j)
          graph[j].append(i)
  
      # 첫 번째 리프 노드 추가
      leaves = []
      for i in range(n + 1):
          if len(graph[i]) == 1:
              leaves.append(i)
  
      # 루트 노드만 남을 때까지 반복 제거
      while n > 2:
          n -= len(leaves)
          new_leaves = []
          for leaf in leaves:
              neighbor = graph[leaf].pop()
              graph[neighbor].remove(leaf)
  
              if len(graph[neighbor]) == 1:
                  new_leaves.append(neighbor)
          leaves = new_leaves
      return leaves
    ```
# 이진 탐색 트리(BSF)
  - 정렬된 트리. 왼쪽 서브트리에는 현재 노드보다 작은 값이, 오른쪽 서브트리에는 현재 노드보다 크거나 같은 값을 지닌 노드들로 이루어져 있는 트리이다.     
  - 따라서 탐색 시 시간 복잡도가 O(logn)이다. 다만 균형이 깨진 트리의 경우 탐색 시 O(n)에 근접한 시간이 소요될 수 있으므로 트리의 균형을 맞추는 것이 중요해진다.
# 자가 균형 이진 탐색 트리
  - 삽입, 삭제 시 자동으로 높이를 작게 유지하는 노드 기반의 이진 탐색 트리다.
  - 대표적인 형태로 AVL 트리와 Red-Black 트리 등이 있다.
# [정렬된 배열의 이진 탐색 트리 변환](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)
💬 오름차순으로 정렬된 배열을 높이 균형 이진 탐색 트리로 변환하라.
  - 풀이 1 이진 검색 결과로 트리 구성
    ```python3
    def SortedArrayToBST(self, nums: List[int]) -> TreeNode:
      if not nums:
          return None
      mid = len(nums) // 2
  
      # 분할 정복으로 이진 검색 결과 트리 구성
      node = TreeNode(nums[mid])
      node.left = self.SortedArrayToBST(nums[:mid])
      node.right = self.SortedArrayToBST(nums[mid + 1:])
      
      return node
    ```
# [이진 탐색 트리(BST)를 더 큰 수 합계 트리로](https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/)
💬 BST의 각 노드를 현재값보다 더 큰 값을 가진 모든 노드의 합으로 만들어라.
  - 풀이 1 중위 순회로 노드 값 누적
    ```python3
    class Solution:
      val: int = 0
  
      def bstToGst(self, root: TreeNode) -> TreeNode:
          # 중위 순회 노드 값 누적
          if root:
              self.bstToGst(root.right)
              self.val += root.val
              root.val = self.val
              self.bstToGst(root.left)
              
          return root
    ```
# [이진 탐색 트리(BST) 합의 범위](https://leetcode.com/problems/range-sum-of-bst/)
  - 풀이 1 재귀 구조 DFS로 브루트 포스 탐색
    ```python3
    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:
      if not root:
          return 0
  
      if root.val < L:
          return self.rangeSumBST(root.right, L, R)
      elif root.val > R:
          return self.rangeSumBST(root.left, L, R)
      return root.val + self.rangeSumBST(root.left, L, R) + self.rangeSumBST(root.right, L, R)
    ```
  - 풀이 2 DFS 가지치기로 필요한 노드 탐색
    ```python3
    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:
      def dfs(node: TreeNode):
          if not node:
              return 0
  
          if node.val < L:
              return dfs(node.right)
          elif node.val > R:
              return dfs(node.left)
          return node.val + dfs(node.left) + dfs(node.right)
      return dfs(root)
    ```
  - 풀이 3 반복 구조 DFS로 필요한 노드 탐색
    ```python3
    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:
      stack, sum = [root], 0
  
      # 스택 이용 필요한 노드 DFS 반복
      while stack:
          node = stack.pop()
          if node:
              if L <= node.val <= R:
                  sum += node.val
              if L < node.val:
                  stack.append(node.left)
              if node.val < R:
                  stack.append(node.right)
      return sum
    ```
  - 풀이 4 반복 구조 BFS로 필요한 노드 탐색
    ```python3
    def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:
      stack, sum = [root], 0
      # 큐 연산을 이용해 반복 구조 BFS로 필요한 노드 탐색
      while stack:
          node = stack.pop(0)
          if node:
              if L < node.val:
                  stack.append(node.left)
              if node.val < R:
                  stack.append(node.right)
              if L <= node.val <= R:
                  sum += node.val
      return sum
    ```
# [이진 탐색 트리(BST) 노드 간 최소 거리](https://leetcode.com/problems/minimum-distance-between-bst-nodes/)
💬 두 노드 간 값의 차이가 가장 작은 노드의 값의 차이를 출력하라.
  - 풀이 1 재귀 구조로 중위 순회
    ```python3
    class Solution:
      prev = -sys.maxsize
      result = sys.maxsize
  
      # 재귀 구조 중위 순회 비교 결과
      def minDiffInBST(self, root: TreeNode) -> int:
          if root.left:
              self.minDiffInBST(root.left)
  
          self.result = min(self.result, root.val - self.prev)
          self.prev = root.val
  
          if root.right:
              self.minDiffInBST(root.right)
  
          return self.result
    ```
  - 풀이 2 반복 구조로 중위 순회
    ```python3
    def minDiffInBST(self, root: TreeNode) -> int:
      prev = -sys.maxsize
      result = sys.maxsize
  
      # 중위 순회
      stack = []
      node = root
  
      # 반복 구조 중위 순회 비교 결과
      while stack or node:
          while node:
              stack.append(node)
              node = node.left
          node = stack.pop()
  
          result = min(result, node.val - prev)
          prev = node.val
  
          node = node.right
  
      return result
    ```
# 트리 순회
  - 그래프 순회의 한 형태로 트리 자료구조에서 각 노드를 정확히 한 번 방문하는 과정
  - L,R,N 으로 왼쪽 서브, 오른쪽 서브, 자기 자신 노드를 말할 때 방문 순서에 따라 3가지 방식으로 구분한다.
    - 전위 순회(Pre-Order) NLR
    - 중위 순회(In-Order) LNR
    - 후위 순회(Post-Order) LRN
![image](https://github.com/user-attachments/assets/0717a17c-0658-4db9-89f0-ecf67e0916be)       

의 경우

```python3
  class Node:
    def __init__(self, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

  root = Node('F',
            Node('B',
                 Node('A'),
                 Node('D',
                      Node('C'), Node('E'))),
            Node('G',
                 None,
                 Node('I', Node('H'))))
## 전위 순회
```python3
def preorder(node):
    if node is None:
        return
    print(node.val, end=' ')
    preorder(node.left)
    preorder(node.right)
```
## 중위 순회
```python3
def inorder(node):
    if node is None:
        return
    inorder(node.left)
    print(node.val, end=' ')
    inorder(node.right)
```
## 후위 순회
```python3
def postorder(node):
    if node is None:
        return
    postorder(node.left)
    postorder(node.right)
    print(node.val, end=' ')
```

# [전위, 중위 순회 결과로 이진 트리 구축](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)
💬 트리의 전휘, 중위 순회 결과를 입력값으로 받아 이진 트리를 구축하라.
  - 풀이 1 전위 순회 결과로 중위 순회 분할 정복
    ```python3
    def buildTree(preorder: List[int], inorder: List[int]) -> TreeNode:
      if inorder:
          # 전위 순회 결과는 중위 순회 분할 인덱스
          index = inorder.index(preorder.pop(0))
  
          # 중위 순회 결과 분할 정복
          node = TreeNode(inorder[index])
          node.left = buildTree(preorder, inorder[0:index])
          node.right = buildTree(preorder, inorder[index + 1:])
          
          return node
    ```






