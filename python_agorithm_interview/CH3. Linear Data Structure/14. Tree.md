# Tree
트리는 계층형 트리 구조를 시뮬레이션 하는 추상 자료형으로 루트 값과 부모-자식 관계의 서브트리로 구성되며, 서로 연결된 노드의 집합이다.
재귀로 정의된 자시 참조 자료구조로 여러 개의 트리(서브 트리)가 쌓아 올려져 큰 트리가 된다.
# 트리의 각 명칭
차수(Degree): 자식 노드의 개수
크기(Size): 자신을 포함한 모든 자식 노드의 개수
높이(height): 현재 위치에서부터 Leaf까지의 거리
깊이(Depth): 루트에서부터 현재 노드까지의 거리
레벨은 0에서부터 시작# Tree
트리는 계층형 트리 구조를 시뮬레이션 하는 추상 자료형으로 루트 값과 부모-자식 관계의 서브트리로 구성되며, 서로 연결된 노드의 집합이다.
재귀로 정의된 자시 참조 자료구조로 여러 개의 트리(서브 트리)가 쌓아 올려져 큰 트리가 된다.
# 트리의 각 명칭
![image](https://github.com/user-attachments/assets/2196e916-b7f7-4c86-8fd6-84d13200a5ee)            
차수(Degree): 자식 노드의 개수           
크기(Size): 자신을 포함한 모든 자식 노드의 개수         
높이(height): 현재 위치에서부터 Leaf까지의 거리           
깊이(Depth): 루트에서부터 현재 노드까지의 거리          
레벨은 0에서부터 시작         
# 그래프 vs 트리
트리는 순환 구조를 갖지 않는 그래프이다.
단방향 연결로만 이루어져 있고 루트, 부모 노드는 하나여야 한다.
# 이진 트리
모든 노드의 차수가 2 이하인 트리
Full binary Tree: 모든 노드가 0 or 2개의 자식 노드를 갖는다.
Complete Binary Tree: 마지막 레벨을 제외하고 모든 레벨이 완전히 채워져 있으면 마지막 레벨의 모든 노드는 가장 왼쪽부터 채워져 있다.
Perfect Binary Tree: 모든 노드가 2개의 자식 모드를 갖고 있으며, 모든 리프 노드가 동일한 깊이 또는 레벨을 갖는다.
# [이진 트리의 최대 깊이](https://leetcode.com/problems/maximum-depth-of-binary-tree/)
이진 트리의 최대 깊이를 구하라.
  - 풀이 1 반복 구조로 BFS 풀이
    - BFS로 풀이하므로 큐 선언
      ```python3
      def maxDepth(self, root: TreeNode) -> int:
      if root is None:
        return 0
      queue = collections.deque([(root])
      depth = 0
      
      while queue:
        depth += 1
        # 큐 연산 추출 노드의 자식 노드 삽입
        for _ in range(len(queue)): # 부모 노드의 길이 만큼만 반복하므로 for 구문 이후에는 부모 노드는 모두 추출되고 바도 다음의 자식 노드들만 큐에 존재
          cur_root = queue.popleft()
          if cur_root.left:
            queue.append(cur_root.left)
          if cur_root.right:
            queue.append(cur_root.right)
      # BFS 반복 횟수 == 깊이
      return depth
    ```
# [이진 트리의 직경](https://leetcode.com/problems/diameter-of-binary-tree/)
이진 트리에서 두 노드 간 가장 긴 경로의 길이를 출력하라.
  - 풀이 1 상태값 누적 트리 DFS
    - dfs는 현재 노드 기준 왼쪽, 오른쪽 서브 트리 중 더 깊은 깊이 +1 반환
    - 현재 노드에서 왼쪽과 오른쪽 서브트리를 연결하는 2개의 간선이므로 left + right + 2와 slef.longest 사이에서 최댓값을 선택한다.
    ```python3
    class Solution:
      longest: int = 0
    
      def diameterOfBinaryTree(self, root: TreeNode) -> int:
        def dfs(node: TreeNode) -> int:
          if not node:
            return -1
          # 왼쪽, 오른쪽의 각 리프 노드까지 탐색
          left = dfs(node.left) # 왼쪽 서브트리에서 가장 깊은 리프 노드까지 가능 경로 길이
          right = dfs(node.right) # 오른쪽 서브트리에서 가장 깊은 리프 노드까지 가능 경로 길이
          # 가장 긴 경로
          self.longest = max(self.longest, left + right + 2)
          # 상태값
          return max(left, right) + 1
        dfs(root)
        return self.longest
    ```
    - 중첩 함수에서 부모 함수의 변수를 재할당하게 되면 참조 ID가 변경되며 별도의 로컬 변수로 선언되어 함수 바깥에서 클래스 변수로 선언 후 사용함
    - 가변객체(리스트, 딕셔너리)일 경우 재할당 없이 조작이 가능하므로 중첩 함수 내에서도 변수의 값을 조작할 수 있다.
# [가장 긴 동일 값의 경로](https://leetcode.com/problems/longest-univalue-path/)
동일한 값을 지닌 가장 긴 경로를 찾아라.
  - 풀이 상태값 거리 계산 DFS
    - 
    ```python3
    class solution:
      result: int = 0
    
      def longestUnivaluePath(self, root: TreeNode) -> int:
        def dfs(node: TreeNode):
          if not node:
            return 0
    
          # 존재하지 않는 노드까지 DFS 재귀 탐색
          left = dfs(node.left)
          right = dfs(node.right)
    
          # 현재 노드가 자식 노드와 동일한 경우 거리 1 증가
          if node.left and node.left.val == node.val:
            left += 1  
          else:
            left = 0
          if node.right and node.right.val == node.val:
            right += 1
          else:
            right = 0
    
    
          # 왼쪽과 오른쪽 자식 노드 간 거리의 합 최댓값이 결과
          self.result = max(self.result, left + right)  
          # 자식 노드 상태값 중 큰 값 리턴
          return max(left, right)  
    
        dfs(root)
        return self.result
    ```




