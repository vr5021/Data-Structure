# 배열
  - 값 도는 변수 엘리먼트의 집합으로 구성된 구조로, 하나 이상의 인덱스 또는 키로 식별된다.
  - 메모리 공간 기반의 연속 방식의 가장 기본이 되는 자료형
## 정적 배열
  - 크기를 지정하고 해당 크기만큼의 연속된 메모리 공간을 할당받는 작업을 수행하는 자료형. 크기가 고정되어 있으며, 한번 생성한 배열은 크기를 변경하는 것이 불가능하다.
  - 메모리 공간 주소는 1바이트마다 1씩 증가하므로 연속된 메모리 공간을 할당받는 특성 상 즉시 주소를 계산할 수 있고 따라서 언제나 O(1)에 조회가 가능하다.
## 동적 배열
  - 크기를 지정하지 않고 자동으로 Resizing하는 배열
  - 미리 초깃값을 작게 잡아 배열을 생성하고, 데이터가 추가되면서 꽉 채워지면, 늘려주고 모두 복사.
  - 재할당 비율을 Growth Factort라 하며 주로 doubling이며 파이썬의 경우는 횟수마다 달라지며 전체적으로는 1.125배이다.
  - 평소에는 O(1)에 조회가 가능하지만 꽉 채워졌을 때 배열 할당과 복사과정에서 O(n)의 시간 복잡도를 가진다.

# [두 수의 합](https://leetcode.com/problems/two-sum/)
  덧셈하여 타겟을 만들 수 있는 배열의 두 숫자 인덱스를 리턴하라.

  - 풀이 1 브루트 포스로 계산(O($n^2$))
    - 배열을 2번 반복하면서 모든 조합을 더해서 일일이 확인해보는 무차별 대입 방식인 Brute-Force 사용
      ```python3
      def twoSum(self, num: List[int], target: int) -> List[int]:
        for i in range(len(nums)):
          for j in range(i + 1, len(nums)):
            if nums[i] + num[j] == target:
                return [i, j]
      ```

  - 풀이 2 in을 이용한 탐색(O($n^2$))
    - 위와 동일한 방식이나 in을 사용한 연산이 훨씬 가볍고 빠르다(상수항 차이)
      ```python3
      def twoSum(self, num: List[int], target: int) -> List[int]:
        for i, n in enumerate(nums):
          complement = target - n

          if complement in nums[i + 1:]:
            return [num.index(n), nums[i + 1:].index(complement) + (i + 1)]
      ```

  - 풀이 3 첫 번째 수를 뺀 결과 키 조회(O(n))
    - 키로 조회
      ```python3
      def twoSum(self, num: List[int], target: int) -> List[int]:
        nums_map = {}
        # 키와 값을 바꿔서 딕셔너리로 저장
        for i, num in enumerate(nums):
          nums_map[num] = i

        # 타겟에서 첫 번째 수를 뺀 결과를 키로 조회
        for i, num in enumerate(nums):
          if target - num in nums_map and i != nums_map[target - num]:
            return [i, nums_map[target -num]]
      ```

  - 풀이 4 조회 구조 계선
    - for 문 최적화
      ```python3
      def twoSum(self, num: List[int], target: int) -> List[int]:
        nums_map = {}
        # 하나의 for 문으로 통합
        for i, num in enumerate(nums):
          if target - num in nums_map 
            return [nums_map[target -num], i]
          nums_map[num] = i
      ```
      
  - 풀이 5 투 포인터 이용
    - 왼쪽 포인터와 오른쪽 포인터의 합이 타겟보다 크다면 오른쪽 포인터를 왼쪽으로, 작다면 왼쪽 포인터를 오른쪽으로 옮기면서 값을 조정
    - 다만 이 경우 정렬된 케이스가 아니므로 적절한 접근 방식이 아니다.
      ```python3
      def twoSum(self, num: List[int], target: int) -> List[int]:
        left, right = 0, len(nums) - 1
        while not left == right:
          # 합이 타겟보다 작으면 왼쪽 포인터를 오른쪽으로
          if nums[left] + nums[right] < target:
            left += 1
          # 합이 타겟보다 크면 오른쪽 포인터를 왼쪽으로
          elif nums[left] + nums[right] > target:
            right -= 1
          else:
            return [left, right]
      ```

# [빗물 트래핑](https://leetcode.com/problems/trapping-rain-water/)
높이를 입력받아 비 온 후 얼마나 많은 물이 쌓일 수 있는지 계산하라
  -풀이 1 투 포인터를 최대로 이동
    - 최대 높이의 막대까지 각각 좌우 기둥 최대 높이와 현재 높이와의 차이만큼 물 높이 volume을 더해 나간다.
    ```python3
    def trap(self, height: List[int]) -> int:
      if not height:
        return 0

      volume = 0
      left, right = 0, len(height) - 1
      left_max, right_max = height[left], height[right]

      while left < right:
       left_max, right_max = max(height[keft], left_max), 
                             max(height[right], right_max)
        # 더 높은 쪽을 향해 투 포인터 이동
        if left_max <= right_max:
          volume += left_max - height[left]
            left += 1
        else:
            volume += right_max - height[right]
            right -= 1
      return volume
      ```
  - 풀이 2 스택 쌓기
    - 스택에 쌓아 나가면서 현재 높이가 이전 높이보다 높을 때마다(Infelction Point) 부분 변속점을 기준으로 격차만큼 물 높이 volume을 채운다.
      ```python3
    def trap(self, height: List[int]) -> int:
      stack = []
      volume = 0
      for i in range(len(heihgt)):
        # 변곡점을 만나는 경우
        while stack and height[i] > height[stack[-1]]:
          # 스택에서 꺼낸다.
          top = stack.pop()

          if not len(stack):
            break

          # 이전과의 차이만큼 물 높이 처리
          distance = i - stack[-1] - 1
          waters = min(height[i], ehight[stack[-1]]) - height[top]

          volume += distance * waters

        stack.append(i)
      return volume
    ```
# [세 수의 합](https://leetcode.com/problems/3sum/)
배열을 입력받아 합으로 0을 만들 수 잇는 3개의 엘리먼트를 출력하라
  - 풀이 1 브루트 포스로 계산
    - sort를 사용해 O(nlog n)으로 정렬 후 브루트 포스로 계산
    - 중복된 값은 continue로 건너뛰기
    ```python3
    def threeSum(self, nums: List[int]) -> List[List[int]]:
      results = []
      nums.sort()

      # 브루트 포스 n^3 반복
      for i in range(len(nums) - 2):
        # 중복된 값 건너뛰기
        if i > 0 and nums[i] -- nums[i -1]:
          continue
        for j in range(i + 1, len(nnums) -1):
          if j > i + 1 and nums[j] == nums[j -1]:
            continue
          for k in range(j + 1, len(nums)):
            if k > j + 1 and nums[k] == nums[k -1 ]:
              continue
            if nums[i] + nums[j] + nums[k] == 0:
              results.append([nums[i], nuuum[j], nums[k]])
      return results
    ```
- 풀이 2 투 포인터로 합 계산
  - sum이 0보다 작으면 left를 우측으로, 크면 right을 왼쪽으로 이동하여 sum이 0일 때 results에 추가
  - 추가한 뒤 양옆에 동일한 값이 있을 수 있으므로 left += 1, right -= 1 반복하여 스킵 처리
    ```python3
    def threeSum(self, nums: List[int]) -> List[List[int]]:
      results = []
      nums.sort()

      for i in range(len(nums) - 2):
        # 중복된 값 건너뛰기
        if i > 0 and nums[i] -- nums[i -1]:
          continue

        # 간격을 좁혀가며 합 sum 계산
        left, right = i + 1, len(nums) - 1
        while left < right:
          sum = nums[i] + nums[left] + nums[right]
          if sum < 0:
            left +=1
          elif sum > 0:
            right -= 1
          else:
            # sum = 0인 경우이므로 정답 및 스킵 처리
            results.append([nums[i], nums[left], nums[right]])

            while left < right and nums[left] == nums[left + 1]:
              left += 1
            while left < right and nums[right] == nums[right - 1]:
              right -= 1
            left += 1
            right -= 1
    
      return results
    ```

# [배열 파티션 I](https://leetcode.com/problems/array-partition-i/)
n 개의 페어를 이용한 min(a, b)의 합으로 만들 수 잇는 가장 큰 수를 출력하라.
  - 풀이 1 오름차순 풀이
    - min 자체도 커야함
    - 뒤에서부터 내림차순으로 집어넣으면 항상 최대 min() 페어 유지
    
        
