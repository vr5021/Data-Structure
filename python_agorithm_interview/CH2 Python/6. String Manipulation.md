문자열을 변경하거나 분리하는 등의 여러 과정

# [유효한 팰린드롬](https://leetcode.com.problems/valid-palindrome/)
  - 풀이 1 리스트로 변환(O($n^2$))
    - 직접 문자열을 입력받아 팰린드롬 여부 판별
    - 대소문자 전처리 우선 구현
      ```python3
      def isPalindrome(self, s: str) -> bool:
        strs = []
        for char in s:
          if char.isalnum():
            strs.append(char.lower())
        while len(strs) > 1:
          if strs.pop(0) != strs.pop():
            return False
        return True
      ```
  - 풀이 2 데크 자료형을 이용한 최적화(O(n))
    - 데크를 명시적으로 선언하여 속도 상승
      ```python3
      def isPalidrome(self, s: str) -> bool:
        strs: Deque = collections.deque()

        for char in s:
          if char.isalnum():
            strs.append(char.lower())
      
        while len(strs) > 1:
          if strs.popleft() != strs.pop():
            return False
        return True
      ```
    - 5배 가까이 속도가 올라감, pop과 popleft 차이
  - 풀이 3 슬라이싱 사용
    ```python3
    def isPalindrome(self, s: str) -> bool:
      s = s.lower()
      # 정규식으로 불필요한 문자 필터링
      s = re.sub('[^a-z0-9]', '', s)
      return s == s[::-1] # reverse 슬라이싱
    ```
  - 문자열 슬라이싱
    - 위치를 지정하면 해당 위치의 배열 포인터를 얻게 되며 이를 통해 연결된 객체를 찾아 실제 값을 찾아내는 과정으로 매우 빠르게 진행된다.
    - 문자열을 조작할 때는 항상 슬라이싱을 우선으로 사용하는 편이 유리하다.
    - S = '안녕하세요'의 경우
      - S[:-3] == 안녕
      - S[-3:] == 하세요
      - S[::1] == 안녕하세요
      - S[::-1] == 요세하녕안
      - S[::2] == 안하요
# [문자열 뒤집기](https://leetcode.com.problems/reverse-string/)
  - 풀이 1 투 포인터를 이용한 스왑
    - 2개의 포인터를 이용해 범위를 조정해가며 풀이하는 방식
    - s 내부를 스왑하는 형태로 풀이
      ```python3
      def reverseString(self, s: List[str]) -> None:
        left, right = 0, len(s) - 1
        while left < right:
          s[left], s[right] = s[right], s[left]
          left += 1
          right -= 1
      ```
  - 풀이 2 파이썬다운 방식(Pythonic way)
    - 파이썬의 기본 기능을 이용해 단 한 줄로 쉽게 풀이할 수 있다.
      ```python3
      def reverseString(self, s: str) -> None:
        s.reverse() # 다만 이 경우 공간 복잡도를 O(1)로 제한하였으므로 오류가 발생한다.
        s[:] = s[::-1] # 따라서 이렇게 수정한다.
      ```
# [로그파일 재정렬](https://leetcode.com/problems/reorder-data-in-log-files/)
  - 로그를 재정렬하라 기준은 다음과 같다.
    1. 로그의 가장 앞 부분은 식별자다.
    2. 문자로 구성된 로그가 숫자 로그보다 앞에 온다.
    3. 식별자는 순서에 영향을 끼치지 않지만, 문자가 동일할 경우 식별자 순으로 한다.
    4. 숫자 로그는 입력 순서대로 한다.
  - 풀이 1 람다와 + 연산자를 이용
    - 문자와 숫자를 구분하고, 숫자는 나중에 그대로 이어 붙인다.
    - 숫자로 변환 가능한 로그는 digits에 그렇지 않은 경우 문자 로그는 letters에 추가
    - 이후 문자 로그를 제대로 정렬하기만 하면 된다.
      ```python3
      def reorderLogFiles(self, logs: List[str]) -> List[str]:
        letters, digits = [], []
        for log in logs:
          if log.split()[1].isdigit():
            digits.append(log)
          else:
              leters.append(log)
        # 2개의 키를 람다 표현식으로 정렬
        letters.sort(key=lamda x: (x.split()[1:], x.split()[0]))
        return letters + digits
      ```
  - 람다 표현식
    - 식별자 없이 실행 가능한 함수. 함수 선언 없이도 하나의 식으로 함수를 단순하게 표현할 수 있다.
    - lambda 매개변수(입력값): 표현식(출력값)
    - 반환값은 표현식의 결과(자동 return)
    - 여러 개의 매개변수도 가능
      
# [가장 흔한 단어](https://leetcode.com/problems/most-common-word/)
  - 금지된 단어를 제외한 가장 흔하게 등장하는 단어르 출력하라. 대소문자 구분을 하지 않으며, 구두점(마침표, 쉼표 등) 또한 무시한다.
  - 풀이 1 리스트 컴프리헨션, Counter 객체 사용
    - 정규식을 사용하여 데이터 전처리를 먼저 한다.
    - 리스트 컴프리헨션을 사용해 조건에 맞는 문자열들로 리스트를 구성한다.
    - Counter 객체를 사용하여 자동으로 가장 흔한 단어를 가져온다.
      ```python3
      def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:
        words =[word for word in re.sub(r'[^\w]', ' ' , paragraph).lower.split() if word not in banned] # 단어문자(\w)가 아닌(^) 것들에 대해 공백(' ')으로 치환하고 소문자로 바꾼뒤 리스트로 만든 객체에서의 요소별로 banned 리스트에 포함되어 있는 않은 단어만 리스트에 포함
        counts =collections.Counter(words)
        # 가장 흔하게 등장하는 단어의 첫 번째 인덱스 리턴
           return count.most_common(1)[0][0]
      ```
# [그룹 애너그램](https://leetcode.com/problems/group-anagrams/)
  - 문자열 배열을 받아 애너그램 단위로 그룹핑하라.
  - 풀이 1 정렬하여 딕셔너리에 추가

    ```python3
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
      anagrams = collections.defaultdict(list)

      for word in strs:
        # 정렬하여 딕셔너리에 추가
        anagrams[''.join(sorted(word))].append(word)
      return list(anagrams.values())
    ```
## 여러 가지 정렬 방법
  - sorted(a), 문자열의 경우 알파벳 단위로 분리해서 정렬 리스트 반환, ley 옵션을 지정해 정렬을 위한 키 또는 함수를 별도로 지정할 수 있다.
  - sort 리스트 자체를 정렬 in-place Sort, 리턴 값이 없다.
  - Timsort
    - 파이썬의 sorted() 정렬 알고리즘으로 실제 데이터는 대부분 이미 정렬되어 있을 것이다'라는 전제하에 고성능을 내도록 설계된 알고리즘
    - 단일 알고리즘이 아닌 삽입 정렬과 병합 정렬을 휴리스틱하게 적절히 조합해 사용하는 정렬 알고리즘
# [가장 긴 팰린드롬 부분 문자열](https://leetcode.com/problems/longest-palindromic-substring/)
  - 가장 긴 팰린드롬 부분 문자열을 출력하라.
  - 풀이 1 중앙을 중심으로 확장하는 풀이
    - 최장 공통 부분 문자열같이 다이나믹 프로그래밍으로 풀 수 있는 전형적인 문제지만 이보다 직관적이면서 훨씬 더 성능이 좋은 투 포인터가 중앙을 중심으로 확장하는 형태로 풀이
    - 2칸, 3칸으로 구성된 투 포인터가 슬라이딩 윈도우처럼 앞으로 전진해 나가다가 윈도우에 들어온 문자열이 팰린드롬인 경우 그 자리에 멈추고 투포인터가 양쪽으로 점점 확장하는 식
    - 팰린드롬은 짝수, 홀수 모두 가능하므로 각 슬라이딩 윈도우는 2 단위로 증가한다.
    - 문자열이 2개보다 작은 경우, 전체가 팰린드롬인 경우 예외처리
      ```python3
      def longestPalindrome(self, s: str) -> str:
        # 팰린드롬 판별 및 투 포인터 확장
        def expand(left: int, right: int) -> str:
          while left >=0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
          return s[left + 1 :right]
        # 해당 사항이 없을 때 빠르게 리턴
        if len(s) < 2 or s== s[::-1]:
          return s
      
        result =''
        # 슬라이딩 윈도우 우측으로 이동
        for i in range(ken(s) - 1):
          result = max(result,
                        expand(i, i + 1),
                        expand(i, i+ 2),
                        key=len)
        return result
      ```
# 유니코드와 UTF-8
  - 초기 문자 표현 방식인 ASCII 인코딩 방식은 1바이트에 모든 무자를 표현하여 1비트는 체크섬으로 제외되어 7비트 총 128글자로 문자를 표현하여 한계가 존재했다.
  - 이를 보완하기 위해 2~4 바이트에 문자를 할당하는 방식이 Unicode이다. 
  - Unicode는 역으로 문자와 관계없이 2바이트 이상의 공간을 차지하므로 비효율적이라는 문제가 존재
  - 이를 보완하기 위해 가변 길이 문자 인코딩으로 효율적인 인코딩 방법인 UTF-8이 제시되었다.
      |바이트 수|바이트 1|바이트 2|바이트 3| 바이트 4|
      |--------|--------|---------|---------|---------|
      |1|0xxxxxxx||||
      |2|110xxxx|10xxxxxx|||
      |3|1110xxxx|10xxxxxx|10xxxxxx||
      |4|11110xxxx|10xxxxxx|10xxxxxx|10xxxxxx|

    
    - 위와 같이 맨 앞 비트를 확인해서 0인 경우 1바이트 문자, 10인 경우 특정 문자의 중간 바이트, 110인 경우 2바이트, 1110인 경우 3 바이트, 11110인 경우 4바이트와 같은 방식으로 문자 바이트의 길이를 인식할 수 있다.
    - 이를 통해 유니코드 값에 따라 가변적으로 바이트를 결정하여 불필요한 공간 낭비를 절약할 수 있다.
  - 다만 파이썬에서는 UTF-8의 경우 문자만다 바이트 길이가 달라지게 되므로 전체 문자열을 스캔하지 않는 한 원하는 인덱스에 빠르게 접근할 수 없어 고정 길이 인코딩 방식인 문자열 단위로 다른 고정 길이 인코딩 방식을 적용한다.(ex. ASKII 범위 내-고정 1바이트, 이외 대부분 문자열-고정 2바이트, 특수 기호, 그림 이모티콘, 희귀 언어등이 포함된 문자열-고정 4바이트)
  
  
    
