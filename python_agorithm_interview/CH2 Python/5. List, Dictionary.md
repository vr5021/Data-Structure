# 리스트
  - 순서대로 저장하는 시퀀스이자 변경 가능한 목록(Mutable List)
  - 입력 순서가 유지되면 내부적으로 동적 배열로 구현되어 있다.
  - 
    |연산|시간 복잡도|설명|
    |-----|----------|----|
    |len(a)|O(1)|전체 요소의 개수를 티런한다.|
    |a[i]|O(1)|인덱스 i의 요소를 가져온다.|
    |a[i:j]|O(k)|인덕세 i부터 j-1까지 슬라이스의 길이만큼인 k개의 요소를 가져온다. 이경우 객체 k개에 대한 조회가 필요하므로 O(k)이다.|
    |x in a|O(n)|x 요소가 존재하는 지 확인 처음부터 순차확인하므로 n만큼 시간 소요|
    |a.count(x)|O(n)|x 요소의 개수를 리턴|
    |a.index(x)|O(n)|x 요소의 인덱스 리턴|
    |a.append(x)|O(1)|리스트 마지막에 x요소 추가|
    |a.pop()|O(1)|리스트 마지막 요소 추출, 스택의 연산|
    |a.pop(0)|O(n)|리스트 첫번째 요소를 추출, 큐의 연산. 이 경우 전체 복사가 필요하므로 O(n)이다. 큐의 연산을 주로 사용한다면 리스트보다는 O(1)에 가능한 deque권장|
    |del a[i]|O(n)|i에 따라 다름 최악의 경우 O(n)|
    |a.sort|O(nlogn)|정렬, Timsort를 사용하며 최선의 경우 O(n)에도 실행가능|
    |min(a), max(a)|O(n)|최솟값/최댓값을 계산하기 위해서는 전체를 선형 탐색해야 함|
    |a.reverse()|O(n)|뒤집는다. 리스트는 입력 순서가 유지되므로 뒤집게 되면 입력 순서가 반대로 된다.|
  - 파이썬의 리스트는 객체에 대한 포인터 목록을 배열 형태로 관리하고 있기 때문에 재각기 다양한 타입을 동시에 단일 리스트에서 관리하는 게 가능하다.
  - 각 자료형의 크기는 서로 다르기 때문에 연속된 메모리 공간에 할당하는 것은 불가능하고 각각의 객체에 대한 참조로 구현할 수밖에 없다.

# 딕셔너리
  - 키/값 구조로 이뤄진 딕셔너리. 입력 순서가 유지되며 내부적으로 해시 테이블로 구현되어 있다.
  - 분할 상환 분석에 따른 시간 복잡도는 O(1)이다.
  - 딕셔너리 모듈
    - defualtdict 객체
      - 존재하지 않는 키를 조회할 경우, 에러 메시지를 출력하는 대신 디폴트 값을 기준으로 해당 키에 대한 딕셔너리 아이템을 생성해준다.
    - Counter 객체
      - 아이템에 대한 개수를 계산한 딕셔너리를 래핑하여 리턴한다.
        ```python3
        a = [1,2,3,4,5,5,5,6,6,]
        b = collections.Counter(a)
        b # Counter({5: 3,, 6: 2, 1: 1, 2: 1, 3: 1, 4: 1})
